diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
new file mode 100644
index 0000000..1eceaae
--- /dev/null
+++ b/src/CMakeLists.txt
@@ -0,0 +1,150 @@
+# openldap cmake based build system
+# copyright (c) 2012 Patrick Spendrin <pspendrin@kde.org>
+
+project(openldap)
+
+cmake_minimum_required(VERSION 3.4)
+
+
+# build options:
+option(BUILD_REENTRANT "build a reentrant library" ON)
+option(BUILD_THREADSAFE "build a threadsafe library" ON)
+option(BUILD_TOOLS "build the ldap tools" ON)
+option(LDAP_DEBUG "define this to add debugging code" ON)
+option(LDAP_LIBS_DYNAMIC "define if LDAP libs are dynamic" ON)
+option(LDAP_PF_INET6 "define to support PF_INET6" ON)
+option(LDAP_PF_LOCAL "define to support PF_LOCAL" OFF) # FIXME sockaddr_un is missing?!?
+option(LDAP_PROCTITLE "define this for LDAP process title support" ON)
+option(LDAP_SLAPI "define this to add SLAPI code" OFF)
+option(LDAP_SYSLOG "define this to add syslog code" OFF)
+
+set(BINDIR "bin")
+set(SBINDIR "bin")
+set(DATADIR "share")
+set(SYSCONFDIR "")
+set(LIBEXECDIR "lib")
+set(MODULEDIR "")
+set(RUNDIR "")
+set(LOCALEDIR "")
+
+set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/modules)
+include(MacroBoolTo01)
+
+if(CONAN_EXPORTED)
+    include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)
+    conan_basic_setup()
+else()
+    # Check build type
+    message(STATUS "CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")
+    set(_supported_build_type "Debug" "Release" "RelWithDebInfo" "MinSizeRel")
+    if((NOT DEFINED CMAKE_BUILD_TYPE) OR (NOT ${CMAKE_BUILD_TYPE} IN_LIST _supported_build_type))
+	    message(FATAL_ERROR "Unknow build type, please specify.\n-DCMAKE_BUILD_TYPE=Debug (either Release, RelWithDebInfo, MinSizeRel)")
+    endif()
+
+    string(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_UPPER)
+
+    # Output directories
+    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
+    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${CMAKE_BUILD_TYPE_UPPER} ${CMAKE_BINARY_DIR}/lib) 
+    if(WIN32)
+        set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
+        set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${CMAKE_BUILD_TYPE_UPPER} ${CMAKE_BINARY_DIR}/lib)
+    else()
+        set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
+        set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${CMAKE_BUILD_TYPE_UPPER} ${CMAKE_BINARY_DIR}/bin)
+    endif()
+    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
+    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${CMAKE_BUILD_TYPE_UPPER} ${CMAKE_BINARY_DIR}/bin)
+    if(MSVC)
+        set(CMAKE_PDB_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
+	    set(CMAKE_PDB_OUTPUT_DIRECTORY_${CMAKE_BUILD_TYPE_UPPER} ${CMAKE_BINARY_DIR}/bin)
+    endif()
+    if(NOT CMAKE_INSTALL_PREFIX OR CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT OR "${CMAKE_INSTALL_PREFIX}" STREQUAL "")
+        set(CMAKE_INSTALL_PREFIX ${CMAKE_BINARY_DIR}/install CACHE PATH "Install path" FORCE)
+        message(STATUS "Autoset CMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}")
+        message(STATUS "Remove directory " ${CMAKE_INSTALL_PREFIX})
+        execute_process(COMMAND ${CMAKE_COMMAND} -E remove_directory ${CMAKE_INSTALL_PREFIX})
+    else()
+        message(STATUS "CMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}")
+    endif()
+
+    message(STATUS "Remove directory " ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
+    execute_process(COMMAND ${CMAKE_COMMAND} -E remove_directory ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
+
+    message(STATUS "Install Conan dependencies")
+
+    set(BUILD_TYPE_FOR_CONAN ${CMAKE_BUILD_TYPE})
+    if(("${CMAKE_BUILD_TYPE}" STREQUAL "RelWithDebInfo") OR ("${CMAKE_BUILD_TYPE}" STREQUAL "MinSizeRel"))
+	    set(BUILD_TYPE_FOR_CONAN "Release")
+    endif()
+
+    include(conan)
+    conan_cmake_run(
+        REQUIRES openssl/1.1.0l+2@odant/stable
+                 pcre/8.43+5@odant/stable
+                 cyrus-sasl/2.1.26+0@odant/testing
+        BUILD_TYPE ${BUILD_TYPE_FOR_CONAN}
+        IMPORTS
+                 "bin, *.* -> ./bin"
+    #    CONANFILE conanfile.py
+        BASIC_SETUP NO_OUTPUT_DIRS UPDATE
+        BUILD outdated
+    )
+
+    message(STATUS "Create install rules for Conan dependencies")
+    file(GLOB CONAN_IMPORTS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/*)
+    foreach(_import_file ${CONAN_IMPORTS})
+        string(TOLOWER ${_import_file} _import_file_lower)
+        if(${_import_file_lower} MATCHES "\\.dll$|\\.so$|\\.so\\.")
+            message(STATUS "Create install rule as program for ${_import_file}")
+            install(PROGRAMS ${_import_file} DESTINATION ${CMAKE_INSTALL_PREFIX})
+	    elseif(${_import_file_lower} MATCHES "\\.pdb$")
+            # Install PDB if needed
+		    if(ODA_INSTALL_PDB_FILES) 
+			    if((${CMAKE_BUILD_TYPE} STREQUAL "Debug") OR (${CMAKE_BUILD_TYPE} STREQUAL "RelWithDebInfo"))
+				    message(STATUS "Create install rule as file for ${_import_file}")
+				    install(FILES ${_import_file} DESTINATION ${CMAKE_INSTALL_PREFIX})
+			    endif()
+		    endif()
+        endif()
+    endforeach()
+    message(STATUS -----------------------------------------------)
+endif()
+#undef LDAP_API_FEATURE_X_OPENLDAP_V2_REFERRALS
+
+set(THREADS_PREFER_PTHREAD_FLAG ON)
+find_package(Threads REQUIRED)
+if(CMAKE_USE_PTHREADS_INIT)
+    set(HAVE_PTHREADS 10)
+endif()
+# find required packages
+find_package(OpenSSL REQUIRED)
+# KDE doesn't provide another pcre library - so accomodate with pcre
+find_package(PCRE REQUIRED)
+find_package(Sasl2)
+
+include_directories(${OPENSSL_INCLUDE_DIR} ${PCRE_INCLUDE_DIR})
+include(ConfigureChecks.cmake)
+
+if(WIN32 AND NOT MINGW)
+    # specially for my friend Andy
+    add_definitions(-wd4996)
+    add_definitions(-Dstrncasecmp=_strnicmp -Dstrcasecmp=_stricmp)
+endif()
+
+set(INSTALL_TARGETS_DEFAULT_ARGS RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)
+
+if(LDAP_LIBS_DYNAMIC)
+    set(LDAP_SHARED SHARED)
+else(LDAP_LIBS_DYNAMIC)
+    set(LDAP_SHARED STATIC)
+endif(LDAP_LIBS_DYNAMIC)
+
+#set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
+
+add_subdirectory(include)
+add_subdirectory(libraries)
+
+if(BUILD_TOOLS)
+    add_subdirectory(clients)
+endif(BUILD_TOOLS)
diff --git a/src/CMakeSettings.json b/src/CMakeSettings.json
new file mode 100644
index 0000000..393cb2c
--- /dev/null
+++ b/src/CMakeSettings.json
@@ -0,0 +1,22 @@
+РїВ»С—{
+  // See https://go.microsoft.com//fwlink//?linkid=834763 for more information about this file.
+  "configurations": [
+    {
+      "name": "x64-Debug",
+      "generator": "Visual Studio 15 2017 Win64",
+      "configurationType": "Debug",
+      "inheritEnvironments": [ "msvc_x64_x64" ],
+      "buildRoot": "${projectDir}\\out\\build\\${name}",
+      "installRoot": "${projectDir}\\out\\install\\${name}",
+      "cmakeCommandArgs": "",
+      "buildCommandArgs": "-m -verbosity:normal",
+      "ctestCommandArgs": "--output-on-failure --verbose",
+      "variables": [
+        {
+          "name": "CMAKE_BUILD_TYPE",
+          "value": "${configurationType}"
+        }
+      ]
+    }
+  ]
+}
\ No newline at end of file
diff --git a/src/ConfigureChecks.cmake b/src/ConfigureChecks.cmake
new file mode 100644
index 0000000..872b59b
--- /dev/null
+++ b/src/ConfigureChecks.cmake
@@ -0,0 +1,549 @@
+if(BUILD_REENTRANT)
+    set(REENTRANT 1)
+    set(_REENTRANT 1)
+endif(BUILD_REENTRANT)
+
+if(BUILD_THREADSAFE)
+    set(THREADSAFE 1)
+    set(_THREADSAFE 1)
+    set(THREAD_SAFE 1)
+    set(_THREAD_SAFE 1)
+endif(BUILD_THREADSAFE)
+
+#/* set to the number of arguments ctime_r() expects */
+set(CTIME_R_NARGS 2) # best guess
+#/* define to enable rewriting in back-ldap and back-meta */
+set(ENABLE_REWRITE 1)
+#/* Define to 1 if the system has the type `ptrdiff_t'. */
+set(HAVE_PTRDIFF_T 1)
+
+if(WIN32)
+    #/* defined to be the EXE extension */
+    set(EXEEXT "\".exe\"")
+    #/* if you have NT Event Log */
+    set(HAVE_NT_EVENT_LOG 1)
+    #/* if you have NT Service Manager */
+    set(HAVE_NT_SERVICE_MANAGER 1)
+    #/* if you have NT Threads */
+    set(HAVE_NT_THREADS 1)
+
+    if(MSVC_VERSION LESS 1899)
+        #/* define to snprintf routine */
+        set(snprintf _snprintf)
+    endif()
+endif()
+
+if(${OPENSSL_FOUND})
+    set(HAVE_OPENSSL 1)
+    #/* define if you have OpenSSL with CRL checking capability */
+    set(HAVE_OPENSSL_CRL 1)
+    #/* define if OpenSSL needs RSAref */
+    set(HAVE_RSAREF 0)
+    list(APPEND CMAKE_REQUIRED_INCLUDES ${OPENSSL_INCLUDE_DIR})
+endif(${OPENSSL_FOUND})
+
+if(${PCRE_FOUND})
+    list(APPEND CMAKE_REQUIRED_INCLUDES "${PCRE_INCLUDE_DIR}")
+endif(${PCRE_FOUND})
+
+
+if(${SASL2_FOUND})
+    #/* define if your SASL library has sasl_version() */
+    set(HAVE_SASL 1)
+    set(HAVE_SASL_VERSION 1)
+    list(APPEND CMAKE_REQUIRED_INCLUDES ${SASL2_INCLUDE_DIR})
+endif(${SASL2_FOUND})
+
+include(CheckIncludeFile)
+include(CheckTypeSize)
+check_include_file("arpa/inet.h" HAVE_ARPA_INET_H)
+check_include_file("arpa/nameser.h" HAVE_ARPA_NAMESER_H)
+check_include_file("assert.h" HAVE_ASSERT_H)
+check_include_file("bits/types.h" HAVE_BITS_TYPES_H)
+check_include_file("conio.h" HAVE_CONIO_H)
+check_include_file("crypt.h" HAVE_CRYPT_H)
+check_include_file("cthreads.h" HAVE_CTHREADS_H)
+check_include_file("db.h" HAVE_DB_H)
+check_include_file("direct.h" HAVE_DIRECT_H)
+check_include_file("dirent.h" HAVE_DIRENT_H)
+check_include_file("dlfcn.h" HAVE_DLFCN_H)
+check_include_file("errno.h" HAVE_ERRNO_H)
+check_include_file("fcntl.h" HAVE_FCNTL_H)
+check_include_file("filio.h" HAVE_FILIO_H)
+check_include_file("getopt.h" HAVE_GETOPT_H)
+check_include_file("gmp.h" HAVE_GMP_H)
+check_include_file("gnutls/gnutls.h" HAVE_GNUTLS_GNUTLS_H)
+check_include_file("grp.h" HAVE_GRP_H)
+check_include_file("inttypes.h" HAVE_INTTYPES_H)
+check_include_file("libutil.h" HAVE_LIBUTIL_H)
+check_include_file("limits.h" HAVE_LIMITS_H)
+check_include_file("locale.h" HAVE_LOCALE_H)
+check_include_file("ltdl.h" HAVE_LTDL_H)
+check_include_file("mach/cthreads.h" HAVE_MACH_CTHREADS_H)
+check_include_file("malloc.h" HAVE_MALLOC_H)
+check_include_file("memory.h" HAVE_MEMORY_H)
+check_include_file("ndir.h" HAVE_NDIR_H)
+check_include_file("netinet/tcp.h" HAVE_NETINET_TCP_H)
+check_include_file("nssutil.h" HAVE_NSSUTIL_H)
+check_include_file("openssl/bn.h" HAVE_OPENSSL_BN_H)
+check_include_file("openssl/crypto.h" HAVE_OPENSSL_CRYPTO_H)
+check_include_file("openssl/ssl.h" HAVE_OPENSSL_SSL_H)
+check_include_file("io.h" HAVE_IO_H)
+check_include_file("poll.h" HAVE_POLL_H)
+check_include_file("process.h" HAVE_PROCESS_H)
+check_include_file("psap.h" HAVE_PSAP_H)
+check_include_file("pthread.h" HAVE_PTHREAD_H)
+check_include_file("pth.h" HAVE_PTH_H)
+check_include_file("pwd.h" HAVE_PWD_H)
+check_include_file("regex.h" HAVE_REGEX_H)
+check_include_file("pcreposix.h" HAVE_PCREPOSIX_H)
+if(HAVE_PCREPOSIX_H)
+    set(HAVE_REGEX_H 1)
+endif(HAVE_PCREPOSIX_H)
+check_include_file("resolv.h" HAVE_RESOLV_H)
+check_include_file("sasl.h" HAVE_SASL_H)
+check_include_file("sasl/sasl.h" HAVE_SASL_SASL_H)
+if(HAVE_SASL_SASL_H OR HAVE_SASL_H)
+    set(HAVE_CYRUS_SASL 1)
+endif()
+check_include_file("sched.h" HAVE_SCHED_H)
+check_include_file("sgtty.h" HAVE_SGTTY_H)
+check_include_file("shadow.h" HAVE_SHADOW_H)
+check_include_file("sqlext.h" HAVE_SQLEXT_H)
+check_include_file("sql.h" HAVE_SQL_H)
+check_include_file("stddef.h" HAVE_STDDEF_H)
+check_include_file("stdint.h" HAVE_STDINT_H)
+check_include_file("stdlib.h" HAVE_STDLIB_H)
+check_include_file("slp.h" HAVE_SLP_H)
+check_include_file("strings.h" HAVE_STRINGS_H)
+check_include_file("string.h" HAVE_STRING_H)
+check_include_file("synch.h" HAVE_SYNCH_H)
+check_include_file("sysexits.h" HAVE_SYSEXITS_H)
+check_include_file("syslog.h" HAVE_SYSLOG_H)
+check_include_file("sys/devpoll.h" HAVE_SYS_DEVPOLL_H)
+check_include_file("sys/dir.h" HAVE_SYS_DIR_H)
+check_include_file("sys/epoll.h" HAVE_SYS_EPOLL_H)
+check_include_file("sys/errno.h" HAVE_SYS_ERRNO_H)
+check_include_file("sys/file.h" HAVE_SYS_FILE_H)
+check_include_file("sys/filio.h" HAVE_SYS_FILIO_H)
+check_include_file("sys/fstyp.h" HAVE_SYS_FSTYP_H)
+check_include_file("sys/ioctl.h" HAVE_SYS_IOCTL_H)
+check_include_file("sys/ndir.h" HAVE_SYS_NDIR_H)
+check_include_file("sys/param.h" HAVE_SYS_PARAM_H)
+check_include_file("sys/poll.h" HAVE_SYS_POLL_H)
+check_include_file("sys/privgrp.h" HAVE_SYS_PRIVGRP_H)
+check_include_file("sys/resource.h" HAVE_SYS_RESOURCE_H)
+check_include_file("sys/select.h" HAVE_SYS_SELECT_H)
+check_include_file("sys/socket.h" HAVE_SYS_SOCKET_H)
+check_include_file("sys/stat.h" HAVE_SYS_STAT_H)
+check_include_file("sys/syslog.h" HAVE_SYS_SYSLOG_H)
+check_include_file("sys/time.h" HAVE_SYS_TIME_H)
+check_include_file("sys/types.h" HAVE_SYS_TYPES_H)
+check_include_file("sys/ucred.h" HAVE_SYS_UCRED_H)
+check_include_file("sys/uio.h" HAVE_SYS_UIO_H)
+check_include_file("sys/un.h" HAVE_SYS_UN_H)
+check_include_file("sys/uuid.h" HAVE_SYS_UUID_H)
+check_include_file("sys/vmount.h" HAVE_SYS_VMOUNT_H)
+check_include_file("sys/wait.h" HAVE_SYS_WAIT_H)
+check_include_file("tcpd.h" HAVE_TCPD_H)
+check_include_file("termios.h" HAVE_TERMIOS_H)
+check_include_file("thread.h" HAVE_THREAD_H)
+check_include_file("unicode/utypes.h" HAVE_UNICODE_UTYPES_H)
+check_include_file("unistd.h" HAVE_UNISTD_H)
+check_include_file("time.h" HAVE_TIME_H)
+check_include_file("utime.h" HAVE_UTIME_H)
+check_include_file("uuid/uuid.h" HAVE_UUID_UUID_H)
+check_include_file("winsock2.h" HAVE_WINSOCK2_H)
+if(HAVE_WINSOCK2_H)
+    set(HAVE_WINSOCK2 1)
+endif()
+check_include_file("winsock.h" HAVE_WINSOCK_H)
+if(HAVE_WINSOCK_H)
+    set(HAVE_WINSOCK 1)
+endif()
+
+if(HAVE_TIME_H AND HAVE_SYS_TIME_H)
+    set(TIME_WITH_SYS_TIME 1)
+endif()
+# berkeley db might be interesting for later usage
+#/* define this if Berkeley DB is available */#undef HAVE_BERKELEY_DB
+#/* define if Berkeley DB has DB_THREAD support */#undef HAVE_BERKELEY_DB_THREAD
+#/* define if you have Cyrus SASL */#undef HAVE_CYRUS_SASL
+#/* define if you have GNUtls */#undef HAVE_GNUTLS
+#/* if you have GNU Pth */#undef HAVE_GNU_PTH
+#/* define if you actually have ICU */#undef HAVE_ICU
+#/* Define to 1 if you have the `gmp' library (-lgmp). */#undef HAVE_LIBGMP
+
+#/* define to use both <string.h> and <strings.h> */#undef BOTH_STRINGS_H
+#/* define if toupper() requires islower() */ #undef C_UPPER_LOWER
+#/* set to the number of arguments gethostbyaddr_r() expects */#undef GETHOSTBYADDR_R_NARGS
+#/* set to the number of arguments gethostbyname_r() expects */#undef GETHOSTBYNAME_R_NARGS
+#/* Define to 1 if `TIOCGWINSZ' requires <sys/ioctl.h>. */#undef GWINSZ_IN_SYS_IOCTL
+#/* define if you have AIX security lib */#undef HAVE_AIX_SECURITY
+
+include(CheckFunctionExists)
+check_function_exists("chroot" HAVE_CHROOT)
+check_function_exists("bcopy" HAVE_BCOPY)
+check_function_exists("closesocket" HAVE_CLOSESOCKET)
+check_function_exists("ctime_r" HAVE_CTIME_R)
+check_function_exists("endgrent" HAVE_ENDGRENT)
+check_function_exists("endpwent" HAVE_ENDPWENT)
+check_function_exists("fcntl" HAVE_FCNTL)
+check_function_exists("flock" HAVE_FLOCK)
+check_function_exists("fstat" HAVE_FSTAT)
+check_function_exists("gai_strerror" HAVE_GAI_STRERROR)
+check_function_exists("getaddrinfo" HAVE_GETADDRINFO)
+check_function_exists("getdtablesize" HAVE_GETDTABLESIZE)
+check_function_exists("geteuid" HAVE_GETEUID)
+check_function_exists("getgrgid" HAVE_GETGRGID)
+check_function_exists("gethostbyaddr_r" HAVE_GETHOSTBYADDR_R)
+check_function_exists("gethostbyname_r" HAVE_GETHOSTBYNAME_R)
+check_function_exists("gethostname" HAVE_GETHOSTNAME)
+check_function_exists("getnameinfo" HAVE_GETNAMEINFO)
+check_function_exists("getopt" HAVE_GETOPT)
+check_function_exists("getpassphrase" HAVE_GETPASSPHRASE)
+check_function_exists("getpeereid" HAVE_GETPEEREID)
+check_function_exists("getpeerucred" HAVE_GETPEERUCRED)
+check_function_exists("getpwnam" HAVE_GETPWNAM)
+check_function_exists("getpwuid" HAVE_GETPWUID)
+check_function_exists("getspnam" HAVE_GETSPNAM)
+check_function_exists("gettimeofday" HAVE_GETTIMEOFDAY)
+check_function_exists("gmtime_r" HAVE_GMTIME_R)
+check_function_exists("hstrerror" HAVE_HSTRERROR)
+check_function_exists("inet_ntoa_b" HAVE_INET_NTOA_B)
+check_function_exists("inet_ntop" HAVE_INET_NTOP)
+check_function_exists("initgroups" HAVE_INITGROUPS)
+check_function_exists("ioctl" HAVE_IOCTL)
+check_function_exists("localtime_r" HAVE_LOCALTIME_R)
+check_function_exists("lockf" HAVE_LOCKF)
+check_function_exists("memcpy" HAVE_MEMCPY)
+check_function_exists("memmove" HAVE_MEMMOVE)
+check_function_exists("memrchr" HAVE_MEMRCHR)
+check_function_exists("mkstemp" HAVE_MKSTEMP)
+check_function_exists("mktemp" HAVE_MKTEMP)
+check_function_exists("pipe" HAVE_PIPE)
+check_function_exists("poll" HAVE_POLL)
+check_function_exists("pthread_detach" HAVE_PTHREAD_DETACH)
+check_function_exists("pthread_getconcurrency" HAVE_PTHREAD_GETCONCURRENCY)
+check_function_exists("pthread_kill" HAVE_PTHREAD_KILL)
+check_function_exists("pthread_kill_other_threads_np" HAVE_PTHREAD_KILL_OTHER_THREADS_NP)
+check_function_exists("pthread_rwlock_destroy function" HAVE_PTHREAD_RWLOCK_DESTROY)
+check_function_exists("pthread_setconcurrency" HAVE_PTHREAD_SETCONCURRENCY)
+check_function_exists("pthread_yield" HAVE_PTHREAD_YIELD)
+check_function_exists("read" HAVE_READ)
+check_function_exists("recv" HAVE_RECV)
+check_function_exists("recvfrom" HAVE_RECVFROM)
+check_function_exists("sched_yield" HAVE_SCHED_YIELD)
+check_function_exists("send" HAVE_SEND)
+check_function_exists("sendmsg" HAVE_SENDMSG)
+check_function_exists("sendto" HAVE_SENDTO)
+check_function_exists("setegid" HAVE_SETEGID)
+check_function_exists("seteuid" HAVE_SETEUID)
+check_function_exists("setgid" HAVE_SETGID)
+check_function_exists("setpwfile" HAVE_SETPWFILE)
+check_function_exists("setsid" HAVE_SETSID)
+check_function_exists("setuid" HAVE_SETUID)
+check_function_exists("sigaction" HAVE_SIGACTION)
+check_function_exists("signal" HAVE_SIGNAL)
+check_function_exists("sigset" HAVE_SIGSET)
+check_function_exists("snprintf" HAVE_SNPRINTF) #Available with MSVC 2015
+#TODO:V2:BUILDSYSTEM:Figure out why check_function_exists fails to find snprintf for MSVC2015
+if(MSVC_VERSION GREATER 1899)
+  set(HAVE_SNPRINTF true)
+endif()
+#check_function_exists("snprintf" HAVE_SNPRINTF)
+check_function_exists("strdup" HAVE_STRDUP)
+check_function_exists("strerror" HAVE_STRERROR)
+check_function_exists("strerror_r" HAVE_STRERROR_R)
+check_function_exists("strftime" HAVE_STRFTIME)
+check_function_exists("strpbrk" HAVE_STRPBRK)
+check_function_exists("strrchr" HAVE_STRRCHR)
+check_function_exists("strsep" HAVE_STRSEP)
+check_function_exists("strspn" HAVE_STRSPN)
+check_function_exists("strstr" HAVE_STRSTR)
+check_function_exists("strtol" HAVE_STRTOL)
+check_function_exists("strtoll" HAVE_STRTOLL)
+check_function_exists("strtoq" HAVE_STRTOQ)
+check_function_exists("strtoul" HAVE_STRTOUL)
+check_function_exists("strtoull" HAVE_STRTOULL)
+check_function_exists("strtouq" HAVE_STRTOUQ)
+check_function_exists("sysconf" HAVE_SYSCONF)
+#check_function_exists("thr_getconcurrency" HAVE_THR_GETCONCURRENCY)
+#check_function_exists("thr_setconcurrency" HAVE_THR_SETCONCURRENCY)
+#check_function_exists("thr_yield" HAVE_THR_YIELD)
+check_function_exists("vprintf" HAVE_VPRINTF)
+check_function_exists("vsnprintf" HAVE_VSNPRINTF)
+check_function_exists("wait4" HAVE_WAIT4)
+check_function_exists("waitpid" HAVE_WAITPID)
+check_function_exists("write" HAVE_WRITE)
+check_function_exists("_vsnprintf" HAVE__VSNPRINTF)
+
+#set(CMAKE_EXTRA_INCLUDE_FILES sys/types.h)
+check_type_size("mode_t" MODE_T_TYPE)
+check_type_size("caddr_t" CADDR_T_TYPE)
+check_type_size("gid_t" GID_T_TYPE)
+check_type_size("pid_t" PID_T_TYPE)
+check_type_size("uid_t" UID_T_TYPE)
+check_type_size("size_t" SIZE_T_TYPE)
+check_type_size("ssize_t" SSIZE_T_TYPE)
+#set(CMAKE_EXTRA_INCLUDE_FILES)
+
+include(CheckCXXSourceCompiles)
+check_cxx_source_compiles(
+"#include <stdio.h>
+#include <sys/types.h>
+#include <errno.h>
+#ifdef _WIN32
+#include <stdlib.h>
+#endif
+int
+main ()
+{
+char *c = (char *) *sys_errlist
+  ;
+  return 0;
+}" HAVE_SYS_ERRLIST)
+
+check_cxx_source_compiles(
+"int
+main ()
+{
+  long long tmp;
+  return 0;
+}" HAVE_LONG_LONG)
+
+#/* define if crypt(3) is available */
+#undef HAVE_CRYPT
+#/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+#undef HAVE_DOPRNT
+#/* define if system uses EBCDIC instead of ASCII */
+#undef HAVE_EBCDIC
+#/* define if your system supports epoll */
+#undef HAVE_EPOLL
+#/* define if you actually have FreeBSD fetch(3) */
+#undef HAVE_FETCH
+#/* define if your system supports /dev/poll */
+#undef HAVE_DEVPOLL
+#/* define to you inet_aton(3) is available */
+#undef HAVE_INET_ATON
+#/* if you have LinuxThreads */
+#undef HAVE_LINUX_THREADS
+#/* define if you have Mach Cthreads */
+#undef HAVE_MACH_CTHREADS
+#/* define this if you have mkversion */
+#undef HAVE_MKVERSION
+#/* define if you have MozNSS */
+#undef HAVE_MOZNSS
+#/* define if strerror_r returns char* instead of int */
+#undef HAVE_NONPOSIX_STRERROR_R
+
+
+
+#/* Define to 1 if you have the `gen' library (-lgen). */
+#undef HAVE_LIBGEN
+#/* Define to 1 if you have the `inet' library (-linet). */
+#undef HAVE_LIBINET
+#/* define if you have libtool -ltdl */
+#undef HAVE_LIBLTDL
+#/* Define to 1 if you have the `net' library (-lnet). */
+#undef HAVE_LIBNET
+#/* Define to 1 if you have the `nsl' library (-lnsl). */
+#undef HAVE_LIBNSL
+#/* Define to 1 if you have the `nsl_s' library (-lnsl_s). */
+#undef HAVE_LIBNSL_S
+#/* Define to 1 if you have the `socket' library (-lsocket). */
+#undef HAVE_LIBSOCKET
+#/* Define to 1 if you have the `V3' library (-lV3). */
+#undef HAVE_LIBV3
+
+#/* Define to 1 if the system has the type `long long'. */
+### set(HAVE_LONG_LONG 1)
+
+#/* define to pthreads API spec revision */
+#undef HAVE_PTHREADS
+#/* define if you have res_query() */
+#undef HAVE_RES_QUERY
+#/* define if setproctitle(3) is available */
+#undef HAVE_SETPROCTITLE
+#/* define if you have -lslp */
+#undef HAVE_SLP
+#/* if you have spawnlp() */
+#undef HAVE_SPAWNLP
+#/* Define to 1 if `msg_accrightslen' is member of `struct msghdr'. */
+#undef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTSLEN
+#/* Define to 1 if `msg_control' is member of `struct msghdr'. */
+#undef HAVE_STRUCT_MSGHDR_MSG_CONTROL
+#/* Define to 1 if `pw_gecos' is member of `struct passwd'. */
+#undef HAVE_STRUCT_PASSWD_PW_GECOS
+#/* Define to 1 if `pw_passwd' is member of `struct passwd'. */
+#undef HAVE_STRUCT_PASSWD_PW_PASSWD
+#/* Define to 1 if `st_blksize' is member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_BLKSIZE
+#/* Define to 1 if `st_fstype' is member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_FSTYPE
+#/* define to 1 if st_fstype is char * */
+#undef HAVE_STRUCT_STAT_ST_FSTYPE_CHAR
+#/* define to 1 if st_fstype is int */
+#undef HAVE_STRUCT_STAT_ST_FSTYPE_INT
+#/* Define to 1 if `st_vfstype' is member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_VFSTYPE
+#/* define if you have -lwrap */
+#undef HAVE_TCPD
+#/* if you have Solaris LWP (thr) package */
+#undef HAVE_THR
+#/* define if you have TLS */
+if(${OPENSSL_FOUND})
+    set(HAVE_TLS 1)
+endif(${OPENSSL_FOUND})
+#/* define if you have uuid_generate() */
+#undef HAVE_UUID_GENERATE
+#/* define if you have uuid_to_str() */
+#undef HAVE_UUID_TO_STR
+#/* define if select implicitly yields */
+#undef HAVE_YIELDING_SELECT
+
+
+#/* define to 32-bit or greater integer type */
+set(LBER_INT_T "int")
+#/* define to large integer type */
+set(LBER_LEN_T "int")
+#/* define to socket descriptor type */
+set(LBER_SOCKET_T "int")
+#/* define to large integer type */
+set(LBER_TAG_T "int")
+
+#########################################################
+#/* define to 1 if library is thread safe */
+if(BUILD_THREADSAFE)
+    set(LDAP_API_FEATURE_X_OPENLDAP_THREAD_SAFE 1)
+endif(BUILD_THREADSAFE)
+
+#/* Major */
+set(LDAP_VENDOR_VERSION_MAJOR 2)
+
+#/* Minor */
+set(LDAP_VENDOR_VERSION_MINOR 4)
+
+#/* Patch */
+set(LDAP_VENDOR_VERSION_PATCH 45)
+
+#/* Build */
+set(LDAP_VENDOR_VERSION_BUILD 2)
+
+#/* RC Versions */
+set(LDAP_RC_FILE_VERSION "${LDAP_VENDOR_VERSION_MAJOR},${LDAP_VENDOR_VERSION_MINOR},${LDAP_VENDOR_VERSION_PATCH},${LDAP_VENDOR_VERSION_BUILD}")
+set(LDAP_RC_PRODUCT_VERSION "${LDAP_VENDOR_VERSION_MAJOR},${LDAP_VENDOR_VERSION_MINOR},${LDAP_VENDOR_VERSION_PATCH},${LDAP_VENDOR_VERSION_BUILD}")
+set(LDAP_RC_FILE_VERSION_STR "\"${LDAP_VENDOR_VERSION_MAJOR}.${LDAP_VENDOR_VERSION_MINOR}.${LDAP_VENDOR_VERSION_PATCH}.${LDAP_VENDOR_VERSION_BUILD}\"")
+set(LDAP_RC_PRODUCT_VERSION_STR "\"${LDAP_VENDOR_VERSION_MAJOR}.${LDAP_VENDOR_VERSION_MINOR}.${LDAP_VENDOR_VERSION_PATCH}.${LDAP_VENDOR_VERSION_BUILD}\"")
+
+#/* Version */
+MATH(EXPR LDAP_VENDOR_VERSION "${LDAP_VENDOR_VERSION_MAJOR} * 10000 + ${LDAP_VENDOR_VERSION_MINOR} * 100 + ${LDAP_VENDOR_VERSION_PATCH}")
+
+#/* define if memcmp is not 8-bit clean or is otherwise broken */
+#undef NEED_MEMCMP_REPLACEMENT
+
+#/* define if you have (or want) no threads */
+#undef NO_THREADS
+
+#/* define to use the original debug style */
+#undef OLD_DEBUG
+
+#/* Package */
+set(OPENLDAP_PACKAGE "\"OpenLDAP\"")
+
+#/* Version */
+set(OPENLDAP_VERSION "\"${LDAP_VENDOR_VERSION_MAJOR}.${LDAP_VENDOR_VERSION_MINOR}.${LDAP_VENDOR_VERSION_PATCH}\"")
+
+#/* Define to the address where bug reports for this package should be sent. */
+set(PACKAGE_BUGREPORT "kde-windows@kde.org")
+#/* Define to the full name of this package. */
+set(PACKAGE_NAME "")
+#/* Define to the full name and version of this package. */
+set(PACKAGE_STRING "")
+#/* Define to the one symbol short name of this package. */
+set(PACKAGE_TARNAME "")
+#/* Define to the version of this package. */
+set(PACKAGE_VERSION "")
+
+#/* define if sched_yield yields the entire process */
+#undef REPLACE_BROKEN_YIELD
+#/* Define to the type of arg 1 for `select'. */
+#undef SELECT_TYPE_ARG1
+#/* Define to the type of args 2, 3 and 4 for `select'. */
+#undef SELECT_TYPE_ARG234
+#/* Define to the type of arg 5 for `select'. */
+#undef SELECT_TYPE_ARG5
+
+#/* The size of `int', as computed by sizeof. */
+set(SIZEOF_INT 4)
+#/* The size of `long', as computed by sizeof. */
+set(SIZEOF_LONG 4)
+#/* The size of `long long', as computed by sizeof. */
+set(SIZEOF_LONG_LONG 8)
+#/* The size of `short', as computed by sizeof. */
+set(SIZEOF_SHORT 2)
+#/* The size of `wchar_t', as computed by sizeof. */
+set(SIZEOF_WCHAR_T 2)
+
+#/* Define as the return type of signal handlers (`int' or `void'). */
+set(RETSIGTYPE void)
+#/* Define to 1 if you have the ANSI C header files. */
+set(STDC_HEADERS 1)
+
+#/* set to urandom device */
+#undef URANDOM_DEVICE
+
+#/* define to use OpenSSL BIGNUM for MP */
+#undef USE_MP_BIGNUM
+
+#/* define to use GMP for MP */
+#undef USE_MP_GMP
+
+#/* define to use 'long' for MP */
+#undef USE_MP_LONG
+
+#/* define to use 'long long' for MP */
+#undef USE_MP_LONG_LONG
+
+#/* Define to 1 if your processor stores words with the most significant byte
+#   first (like Motorola and SPARC, unlike Intel and VAX). */
+#undef WORDS_BIGENDIAN
+
+#/* Define to the type of arg 3 for `accept'. */
+set(ber_socklen_t int)
+#/* Define to `char *' if <sys/types.h> does not define. */
+if(NOT HAVE_CADDR_T_TYPE)
+    set(caddr_t "char*")
+endif()
+#/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+#/* Define to `int' if <sys/types.h> doesn't define. */
+if(NOT HAVE_GID_T_TYPE)
+    set(gid_t int)
+endif()
+#/* Define to `int' if <sys/types.h> does not define. */
+if(NOT HAVE_MODE_T_TYPE)
+    set(mode_t int)
+endif()
+#/* Define to `long' if <sys/types.h> does not define. */
+#set(off_t long)
+#/* Define to `int' if <sys/types.h> does not define. */
+if(NOT HAVE_PID_T_TYPE)
+    set(pid_t int)
+endif()
+#/* Define to `int' if <signal.h> does not define. */
+#set(sig_atomic_t int)
+#/* Define to `unsigned' if <sys/types.h> does not define. */
+if(NOT HAVE_SIZE_T_TYPE) 
+    set(size_t unsigned int)
+endif()
+#/* Define like ber_socklen_t if <sys/socket.h> does not define. */
+#undef socklen_t
+#/* Define to `signed int' if <sys/types.h> does not define. */
+if(NOT HAVE_SSIZE_T_TYPE) 
+    set(ssize_t signed int)
+endif()
+#/* Define to `int' if <sys/types.h> doesn't define. */
+if(NOT HAVE_UID_T_TYPE)
+    set(uid_t int)
+endif()
diff --git a/src/ConfigureOptions.cmake b/src/ConfigureOptions.cmake
new file mode 100644
index 0000000..8fd62c2
--- /dev/null
+++ b/src/ConfigureOptions.cmake
@@ -0,0 +1,45 @@
+option(SLAPD_ACI_ENABLED "per-object ACIs" OFF)
+option(SLAPD_BDB "BDB backend" OFF)
+option(SLAPD_CLEARTEXT "cleartext passwords" OFF)
+option(SLAPD_CRYPT "crypt(3 OFF) passwords" OFF)
+option(SLAPD_DNSSRV "DNS SRV backend" OFF)
+option(SLAPD_HDB "HDB backend" OFF)
+option(SLAPD_LDAP "LDAP backend" OFF)
+option(SLAPD_LMHASH "LAN Manager passwords" OFF)
+option(SLAPD_MDB "MDB backend" OFF)
+option(SLAPD_META "LDAP Metadirectory backend" OFF)
+option(SLAPD_MODULES "modules" OFF)
+#option(SLAPD_MOD_DYNAMIC "dynamically linked module" OFF)
+#option(SLAPD_MOD_STATIC "statically linked module" OFF)
+#option(SLAPD_MONITOR "cn=Monitor backend" OFF)
+option(SLAPD_NDB "NDB backend" OFF)
+option(SLAPD_NULL "NULL backend" ON)
+option(SLAPD_OVER_ACCESSLOG "In-Directory Access Logging overlay" OFF)
+option(SLAPD_OVER_AUDITLOG "Audit Logging overlay" OFF)
+option(SLAPD_OVER_COLLECT "Collect overlay" OFF)
+option(SLAPD_OVER_CONSTRAINT "Attribute Constraint overlay" OFF)
+option(SLAPD_OVER_DDS "Dynamic Directory Services overlay" OFF)
+option(SLAPD_OVER_DEREF "Dynamic Directory Services overlay" OFF)
+option(SLAPD_OVER_DYNGROUP "Dynamic Group overlay" OFF)
+option(SLAPD_OVER_DYNLIST "Dynamic List overlay" OFF)
+option(SLAPD_OVER_MEMBEROF "Reverse Group Membership overlay" OFF)
+option(SLAPD_OVER_PPOLICY "Password Policy overlay" OFF)
+option(SLAPD_OVER_PROXYCACHE "Proxy Cache overlay" OFF)
+option(SLAPD_OVER_REFINT "Referential Integrity overlay" OFF)
+option(SLAPD_OVER_RETCODE "Referential Integrity overlay" OFF)
+option(SLAPD_OVER_RWM "Rewrite/Remap overlay" OFF)
+option(SLAPD_OVER_SEQMOD "Sequential Modify overlay" OFF)
+option(SLAPD_OVER_SSSVLV "ServerSideSort/VLV overlay" OFF)
+option(SLAPD_OVER_SYNCPROV "Syncrepl Provider overlay" OFF)
+option(SLAPD_OVER_TRANSLUCENT "Translucent Proxy overlay" OFF)
+option(SLAPD_OVER_UNIQUE "Attribute Uniqueness overlay" OFF)
+option(SLAPD_OVER_VALSORT "Value Sorting overlay" OFF)
+option(SLAPD_PASSWD "PASSWD backend" OFF)
+option(SLAPD_PERL "PERL backend" OFF)
+option(SLAPD_RELAY "relay backend" OFF)
+option(SLAPD_RLOOKUPS "reverse lookups" OFF)
+option(SLAPD_SHELL "SHELL backend" OFF)
+option(SLAPD_SOCK "SOCK backend" OFF)
+option(SLAPD_SPASSWD "SASL passwords" OFF)
+option(SLAPD_SQL "SQL backend" OFF)
+option(SLAP_DYNACL "run-time loadable ACL" OFF)
diff --git a/src/build/mkversion b/src/build/mkversion
index 7010640..c604775 100644
--- a/src/build/mkversion
+++ b/src/build/mkversion
@@ -17,7 +17,7 @@
 PACKAGE=OpenLDAP
 VERSION=unknown
 SYMBOL=__Version
-static=static
+static=
 const=const
 while :
 	do case "$1" in
@@ -71,8 +71,10 @@ static const char copyright[] =
 "Copyright 1998-2017 The OpenLDAP Foundation.  All rights reserved.\n"
 "COPYING RESTRICTIONS APPLY\n";
 
+#include "portable.h"
+
 $static $const char $SYMBOL[] =
-"@(#) \$$PACKAGE: $APPLICATION $VERSION (" __DATE__ " " __TIME__ ") \$\n"
+"@(#) \$" OPENLDAP_PACKAGE ": $APPLICATION " OPENLDAP_VERSION "(" __DATE__ " " __TIME__ ") \$\n"
 "\t$WHOWHERE\n";
 
 __EOF__
diff --git a/src/clients/CMakeLists.txt b/src/clients/CMakeLists.txt
new file mode 100644
index 0000000..8ec9d5f
--- /dev/null
+++ b/src/clients/CMakeLists.txt
@@ -0,0 +1,2 @@
+include_directories(${CMAKE_SOURCE_DIR}/include ${CMAKE_BINARY_DIR}/include)
+add_subdirectory(tools)
diff --git a/src/clients/tools/CMakeLists.txt b/src/clients/tools/CMakeLists.txt
new file mode 100644
index 0000000..bd0edd1
--- /dev/null
+++ b/src/clients/tools/CMakeLists.txt
@@ -0,0 +1,38 @@
+set(ldap_tools
+    ldapsearch
+    ldapmodify
+    ldapdelete
+    ldapmodrdn
+    ldappasswd
+    ldapwhoami
+    ldapcompare
+    ldapexop
+    ldapurl
+)
+
+foreach(_tool ${ldap_tools})
+    # the next file was called ld[dmprsvu]version.c but is renamed here
+    file(TO_NATIVE_PATH ${CMAKE_SOURCE_DIR}/build/version.h _version_h)
+    file(TO_NATIVE_PATH ${CMAKE_CURRENT_BINARY_DIR}/${_tool}_version.c _version_c)
+    if(MINGW)
+        string(REPLACE "/" "\\" _version_h ${_version_h})
+        string(REPLACE "/" "\\" _version_c ${_version_c})
+    endif(MINGW)
+    if(WIN32)
+        add_custom_command(OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${_tool}_version.c"
+                           COMMAND ${CMAKE_SOURCE_DIR}/build/mkvers.bat
+                           ARGS ${_version_h} ${_version_c} ${_tool} > NUL)
+    else()
+        add_custom_command(OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${_tool}_version.c"
+                           COMMAND ${CMAKE_SOURCE_DIR}/build/mkversion
+                           ARGS ${_tool} > "${CMAKE_CURRENT_BINARY_DIR}/${_tool}_version.c")
+    endif()
+    set(${_tool}_SRCS ${_tool}.c ${_tool}_version.c)
+    if(NOT ${_tool} MATCHES ldapurl)
+        list(APPEND ${_tool}_SRCS common.c)
+    endif(NOT ${_tool} MATCHES ldapurl)
+    add_executable(${_tool} ${${_tool}_SRCS})
+    target_link_libraries(${_tool} lber lutil ldap_r Threads::Threads)
+endforeach(_tool ${ldap_tools})
+
+install(TARGETS ${ldap_tools} ${INSTALL_TARGETS_DEFAULT_ARGS})
diff --git a/src/clients/tools/ldapsearch.c b/src/clients/tools/ldapsearch.c
index 894b647..e5796fa 100644
--- a/src/clients/tools/ldapsearch.c
+++ b/src/clients/tools/ldapsearch.c
@@ -71,6 +71,10 @@
 
 #include "common.h"
 
+#ifdef _WIN32
+#    include <winsock2.h>
+#endif
+
 #if !LDAP_DEPRECATED
 /*
  * NOTE: we use this deprecated function only because
diff --git a/src/cmake/modules/FindSasl2.cmake b/src/cmake/modules/FindSasl2.cmake
new file mode 100644
index 0000000..9fe12ea
--- /dev/null
+++ b/src/cmake/modules/FindSasl2.cmake
@@ -0,0 +1,26 @@
+# - Try to find the sasl2 directory library
+# Once done this will define
+#
+#  SASL2_FOUND - system has SASL2
+#  SASL2_INCLUDE_DIR - the SASL2 include directory
+#  SASL2_LIBRARIES - The libraries needed to use SASL2
+
+# Copyright (c) 2006, 2007 Laurent Montel, <montel@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+find_path(SASL2_INCLUDE_DIR sasl/sasl.h
+)
+
+# libsasl2 add for windows, because the windows package of cyrus-sasl2
+# contains a libsasl2 also for msvc which is not standard conform
+find_library(SASL2_LIBRARIES NAMES sasl2 libsasl2
+)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Sasl2  DEFAULT_MSG  SASL2_LIBRARIES SASL2_INCLUDE_DIR)
+
+mark_as_advanced(SASL2_INCLUDE_DIR SASL2_LIBRARIES)
+
diff --git a/src/cmake/modules/MacroBoolTo01.cmake b/src/cmake/modules/MacroBoolTo01.cmake
new file mode 100644
index 0000000..63b9852
--- /dev/null
+++ b/src/cmake/modules/MacroBoolTo01.cmake
@@ -0,0 +1,20 @@
+# MACRO_BOOL_TO_01( VAR RESULT0 ... RESULTN )
+# This macro evaluates its first argument
+# and sets all the given vaiables either to 0 or 1
+# depending on the value of the first one
+
+# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+MACRO(MACRO_BOOL_TO_01 FOUND_VAR )
+   FOREACH (_current_VAR ${ARGN})
+      IF(${FOUND_VAR})
+         SET(${_current_VAR} 1)
+      ELSE(${FOUND_VAR})
+         SET(${_current_VAR} 0)
+      ENDIF(${FOUND_VAR})
+   ENDFOREACH(_current_VAR)
+ENDMACRO(MACRO_BOOL_TO_01)
diff --git a/src/cmake/modules/PrepareConfigureFile.cmake b/src/cmake/modules/PrepareConfigureFile.cmake
new file mode 100644
index 0000000..2f2bd83
--- /dev/null
+++ b/src/cmake/modules/PrepareConfigureFile.cmake
@@ -0,0 +1,12 @@
+# this macro is used to bring the template header syntax of ldap to the cmake syntax
+macro(prepare_configure_file _infile)
+    string(LENGTH ${_infile} __namelength)
+    math(EXPR __namelength "${__namelength} - 2")
+    string(SUBSTRING ${_infile} 0 ${__namelength} __outfile)
+    file(RELATIVE_PATH __outfile ${CMAKE_SOURCE_DIR}/include ${__outfile})
+    file(READ ${_infile} __content)
+    string(REPLACE ";" "\\;" __content "${__content}") # make sure that also ; get through cmake and won't get interpreted as array separators
+    string(REGEX REPLACE "\#undef ([^\r\n ]*)" "#cmakedefine \\1 @\\1@" __content "${__content}")
+    string(REGEX REPLACE "%([A-Za-z0-9_]*)%" "@\\1@" __content "${__content}")
+    file(WRITE ${CMAKE_BINARY_DIR}/${__outfile}.cmake ${__content})
+endmacro(prepare_configure_file _infile)
diff --git a/src/cmake/modules/conan.cmake b/src/cmake/modules/conan.cmake
new file mode 100644
index 0000000..b27dc33
--- /dev/null
+++ b/src/cmake/modules/conan.cmake
@@ -0,0 +1,610 @@
+# The MIT License (MIT)
+
+# Copyright (c) 2018 JFrog
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in all
+# copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+
+
+# This file comes from: https://github.com/conan-io/cmake-conan. Please refer
+# to this repository for issues and documentation.
+
+# Its purpose is to wrap and launch Conan C/C++ Package Manager when cmake is called.
+# It will take CMake current settings (os, compiler, compiler version, architecture)
+# and translate them to conan settings for installing and retrieving dependencies.
+
+# It is intended to facilitate developers building projects that have conan dependencies,
+# but it is only necessary on the end-user side. It is not necessary to create conan
+# packages, in fact it shouldn't be use for that. Check the project documentation.
+
+# version: 0.15.0
+
+include(CMakeParseArguments)
+
+function(_get_msvc_ide_version result)
+    set(${result} "" PARENT_SCOPE)
+    if(NOT MSVC_VERSION VERSION_LESS 1400 AND MSVC_VERSION VERSION_LESS 1500)
+        set(${result} 8 PARENT_SCOPE)
+    elseif(NOT MSVC_VERSION VERSION_LESS 1500 AND MSVC_VERSION VERSION_LESS 1600)
+        set(${result} 9 PARENT_SCOPE)
+    elseif(NOT MSVC_VERSION VERSION_LESS 1600 AND MSVC_VERSION VERSION_LESS 1700)
+        set(${result} 10 PARENT_SCOPE)
+    elseif(NOT MSVC_VERSION VERSION_LESS 1700 AND MSVC_VERSION VERSION_LESS 1800)
+        set(${result} 11 PARENT_SCOPE)
+    elseif(NOT MSVC_VERSION VERSION_LESS 1800 AND MSVC_VERSION VERSION_LESS 1900)
+        set(${result} 12 PARENT_SCOPE)
+    elseif(NOT MSVC_VERSION VERSION_LESS 1900 AND MSVC_VERSION VERSION_LESS 1910)
+        set(${result} 14 PARENT_SCOPE)
+    elseif(NOT MSVC_VERSION VERSION_LESS 1910 AND MSVC_VERSION VERSION_LESS 1920)
+        set(${result} 15 PARENT_SCOPE)
+    elseif(NOT MSVC_VERSION VERSION_LESS 1920 AND MSVC_VERSION VERSION_LESS 1930)
+        set(${result} 16 PARENT_SCOPE)
+    else()
+        message(FATAL_ERROR "Conan: Unknown MSVC compiler version [${MSVC_VERSION}]")
+    endif()
+endfunction()
+
+function(conan_cmake_settings result)
+    #message(STATUS "COMPILER " ${CMAKE_CXX_COMPILER})
+    #message(STATUS "COMPILER " ${CMAKE_CXX_COMPILER_ID})
+    #message(STATUS "VERSION " ${CMAKE_CXX_COMPILER_VERSION})
+    #message(STATUS "FLAGS " ${CMAKE_LANG_FLAGS})
+    #message(STATUS "LIB ARCH " ${CMAKE_CXX_LIBRARY_ARCHITECTURE})
+    #message(STATUS "BUILD TYPE " ${CMAKE_BUILD_TYPE})
+    #message(STATUS "GENERATOR " ${CMAKE_GENERATOR})
+    #message(STATUS "GENERATOR WIN64 " ${CMAKE_CL_64})
+
+    message(STATUS "Conan: Automatic detection of conan settings from cmake")
+
+    parse_arguments(${ARGV})
+
+    if(ARGUMENTS_BUILD_TYPE)
+        set(_CONAN_SETTING_BUILD_TYPE ${ARGUMENTS_BUILD_TYPE})
+    elseif(CMAKE_BUILD_TYPE)
+        set(_CONAN_SETTING_BUILD_TYPE ${CMAKE_BUILD_TYPE})
+    else()
+        message(FATAL_ERROR "Please specify in command line CMAKE_BUILD_TYPE (-DCMAKE_BUILD_TYPE=Release)")
+    endif()
+
+    string(TOUPPER ${_CONAN_SETTING_BUILD_TYPE} _CONAN_SETTING_BUILD_TYPE_UPPER)
+    if (_CONAN_SETTING_BUILD_TYPE_UPPER STREQUAL "DEBUG")
+        set(_CONAN_SETTING_BUILD_TYPE "Debug")
+    elseif(_CONAN_SETTING_BUILD_TYPE_UPPER STREQUAL "RELEASE")
+        set(_CONAN_SETTING_BUILD_TYPE "Release")
+    elseif(_CONAN_SETTING_BUILD_TYPE_UPPER STREQUAL "RELWITHDEBINFO")
+        set(_CONAN_SETTING_BUILD_TYPE "RelWithDebInfo")
+    elseif(_CONAN_SETTING_BUILD_TYPE_UPPER STREQUAL "MINSIZEREL")
+        set(_CONAN_SETTING_BUILD_TYPE "MinSizeRel")
+    endif()
+
+    if(ARGUMENTS_ARCH)
+        set(_CONAN_SETTING_ARCH ${ARGUMENTS_ARCH})
+    endif()
+    #handle -s os setting
+    if(CMAKE_SYSTEM_NAME)
+        #use default conan os setting if CMAKE_SYSTEM_NAME is not defined
+        set(CONAN_SYSTEM_NAME ${CMAKE_SYSTEM_NAME})
+        if(${CMAKE_SYSTEM_NAME} STREQUAL "Darwin")
+            set(CONAN_SYSTEM_NAME Macos)
+        endif()
+        set(CONAN_SUPPORTED_PLATFORMS Windows Linux Macos Android iOS FreeBSD WindowsStore)
+        list (FIND CONAN_SUPPORTED_PLATFORMS "${CONAN_SYSTEM_NAME}" _index)
+        if (${_index} GREATER -1)
+            #check if the cmake system is a conan supported one
+            set(_CONAN_SETTING_OS ${CONAN_SYSTEM_NAME})
+        else()
+            message(FATAL_ERROR "cmake system ${CONAN_SYSTEM_NAME} is not supported by conan. Use one of ${CONAN_SUPPORTED_PLATFORMS}")
+        endif()
+    endif()
+
+    get_property(_languages GLOBAL PROPERTY ENABLED_LANGUAGES)
+    if (";${_languages};" MATCHES ";CXX;")
+        set(LANGUAGE CXX)
+        set(USING_CXX 1)
+    elseif (";${_languages};" MATCHES ";C;")
+        set(LANGUAGE C)
+        set(USING_CXX 0)
+    else ()
+        message(FATAL_ERROR "Conan: Neither C or C++ was detected as a language for the project. Unabled to detect compiler version.")
+    endif()
+
+    if (${CMAKE_${LANGUAGE}_COMPILER_ID} STREQUAL GNU)
+        # using GCC
+        # TODO: Handle other params
+        string(REPLACE "." ";" VERSION_LIST ${CMAKE_${LANGUAGE}_COMPILER_VERSION})
+        list(GET VERSION_LIST 0 MAJOR)
+        list(GET VERSION_LIST 1 MINOR)
+        set(COMPILER_VERSION ${MAJOR}.${MINOR})
+        if(${MAJOR} GREATER 4)
+            set(COMPILER_VERSION ${MAJOR})
+        endif()
+        set(_CONAN_SETTING_COMPILER gcc)
+        set(_CONAN_SETTING_COMPILER_VERSION ${COMPILER_VERSION})
+        if (USING_CXX)
+            conan_cmake_detect_unix_libcxx(_LIBCXX)
+            set(_CONAN_SETTING_COMPILER_LIBCXX ${_LIBCXX})
+        endif ()
+    elseif (${CMAKE_${LANGUAGE}_COMPILER_ID} STREQUAL AppleClang)
+        # using AppleClang
+        string(REPLACE "." ";" VERSION_LIST ${CMAKE_${LANGUAGE}_COMPILER_VERSION})
+        list(GET VERSION_LIST 0 MAJOR)
+        list(GET VERSION_LIST 1 MINOR)
+        set(_CONAN_SETTING_COMPILER apple-clang)
+        set(_CONAN_SETTING_COMPILER_VERSION ${MAJOR}.${MINOR})
+        if (USING_CXX)
+            conan_cmake_detect_unix_libcxx(_LIBCXX)
+            set(_CONAN_SETTING_COMPILER_LIBCXX ${_LIBCXX})
+        endif ()
+    elseif (${CMAKE_${LANGUAGE}_COMPILER_ID} STREQUAL Clang)
+        string(REPLACE "." ";" VERSION_LIST ${CMAKE_${LANGUAGE}_COMPILER_VERSION})
+        list(GET VERSION_LIST 0 MAJOR)
+        list(GET VERSION_LIST 1 MINOR)
+        set(_CONAN_SETTING_COMPILER clang)
+        set(_CONAN_SETTING_COMPILER_VERSION ${MAJOR}.${MINOR})
+        if(APPLE)
+            cmake_policy(GET CMP0025 APPLE_CLANG_POLICY)
+            if(NOT APPLE_CLANG_POLICY STREQUAL NEW)
+                message(STATUS "Conan: APPLE and Clang detected. Assuming apple-clang compiler. Set CMP0025 to avoid it")
+                set(_CONAN_SETTING_COMPILER apple-clang)
+            endif()
+        endif()
+        if(${_CONAN_SETTING_COMPILER} STREQUAL clang AND ${MAJOR} GREATER 7)
+            set(_CONAN_SETTING_COMPILER_VERSION ${MAJOR})
+        endif()
+        if (USING_CXX)
+            conan_cmake_detect_unix_libcxx(_LIBCXX)
+            set(_CONAN_SETTING_COMPILER_LIBCXX ${_LIBCXX})
+        endif ()
+    elseif(${CMAKE_${LANGUAGE}_COMPILER_ID} STREQUAL MSVC)
+        set(_VISUAL "Visual Studio")
+        _get_msvc_ide_version(_VISUAL_VERSION)
+        if("${_VISUAL_VERSION}" STREQUAL "")
+            message(FATAL_ERROR "Conan: Visual Studio not recognized")
+        else()
+            set(_CONAN_SETTING_COMPILER ${_VISUAL})
+            set(_CONAN_SETTING_COMPILER_VERSION ${_VISUAL_VERSION})
+        endif()
+
+        if(NOT _CONAN_SETTING_ARCH)
+            if (MSVC_${LANGUAGE}_ARCHITECTURE_ID MATCHES "64")
+                set(_CONAN_SETTING_ARCH x86_64)
+            elseif (MSVC_${LANGUAGE}_ARCHITECTURE_ID MATCHES "^ARM")
+                message(STATUS "Conan: Using default ARM architecture from MSVC")
+                set(_CONAN_SETTING_ARCH armv6)
+            elseif (MSVC_${LANGUAGE}_ARCHITECTURE_ID MATCHES "86")
+                set(_CONAN_SETTING_ARCH x86)
+            else ()
+                message(FATAL_ERROR "Conan: Unknown MSVC architecture [${MSVC_${LANGUAGE}_ARCHITECTURE_ID}]")
+            endif()
+        endif()
+
+        conan_cmake_detect_vs_runtime(_vs_runtime)
+        message(STATUS "Conan: Detected VS runtime: ${_vs_runtime}")
+        set(_CONAN_SETTING_COMPILER_RUNTIME ${_vs_runtime})
+
+        if (CMAKE_GENERATOR_TOOLSET)
+            set(_CONAN_SETTING_COMPILER_TOOLSET ${CMAKE_VS_PLATFORM_TOOLSET})
+        elseif(CMAKE_VS_PLATFORM_TOOLSET AND (CMAKE_GENERATOR STREQUAL "Ninja"))
+            set(_CONAN_SETTING_COMPILER_TOOLSET ${CMAKE_VS_PLATFORM_TOOLSET})
+        endif()
+    else()
+        message(FATAL_ERROR "Conan: compiler setup not recognized")
+    endif()
+
+    # If profile is defined it is used
+    if(CMAKE_BUILD_TYPE STREQUAL "Debug" AND ARGUMENTS_DEBUG_PROFILE)
+        set(_APPLIED_PROFILES ${ARGUMENTS_DEBUG_PROFILE})
+    elseif(CMAKE_BUILD_TYPE STREQUAL "Release" AND ARGUMENTS_RELEASE_PROFILE)
+        set(_APPLIED_PROFILES ${ARGUMENTS_RELEASE_PROFILE})
+    elseif(CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo" AND ARGUMENTS_RELWITHDEBINFO_PROFILE)
+        set(_APPLIED_PROFILES ${ARGUMENTS_RELWITHDEBINFO_PROFILE})
+    elseif(CMAKE_BUILD_TYPE STREQUAL "MinSizeRel" AND ARGUMENTS_MINSIZEREL_PROFILE)
+        set(_APPLIED_PROFILES ${ARGUMENTS_MINSIZEREL_PROFILE})
+    elseif(ARGUMENTS_PROFILE)
+        set(_APPLIED_PROFILES ${ARGUMENTS_PROFILE})
+    endif()
+
+    foreach(ARG ${_APPLIED_PROFILES})
+        set(_SETTINGS ${_SETTINGS} -pr=${ARG})
+    endforeach()
+
+    if(NOT _SETTINGS OR ARGUMENTS_PROFILE_AUTO STREQUAL "ALL")
+        set(ARGUMENTS_PROFILE_AUTO arch build_type compiler compiler.version
+                                   compiler.runtime compiler.libcxx compiler.toolset)
+    endif()
+
+    # Automatic from CMake
+    foreach(ARG ${ARGUMENTS_PROFILE_AUTO})
+        string(TOUPPER ${ARG} _arg_name)
+        string(REPLACE "." "_" _arg_name ${_arg_name})
+        if(_CONAN_SETTING_${_arg_name})
+            set(_SETTINGS ${_SETTINGS} -s ${ARG}=${_CONAN_SETTING_${_arg_name}})
+        endif()
+    endforeach()
+
+    foreach(ARG ${ARGUMENTS_SETTINGS})
+        set(_SETTINGS ${_SETTINGS} -s ${ARG})
+    endforeach()
+
+    message(STATUS "Conan: Settings= ${_SETTINGS}")
+
+    set(${result} ${_SETTINGS} PARENT_SCOPE)
+endfunction()
+
+
+function(conan_cmake_detect_unix_libcxx result)
+    # Take into account any -stdlib in compile options
+    get_directory_property(compile_options DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} COMPILE_OPTIONS)
+
+    # Take into account any _GLIBCXX_USE_CXX11_ABI in compile definitions
+    get_directory_property(defines DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} COMPILE_DEFINITIONS)
+    foreach(define ${defines})
+        if(define MATCHES "_GLIBCXX_USE_CXX11_ABI")
+            if(define MATCHES "^-D")
+                set(compile_options ${compile_options} "${define}")
+            else()
+                set(compile_options ${compile_options} "-D${define}")
+            endif()
+        endif()
+    endforeach()
+
+    execute_process(
+        COMMAND ${CMAKE_COMMAND} -E echo "#include <string>"
+        COMMAND ${CMAKE_CXX_COMPILER} -x c++ ${compile_options} -E -dM -
+        OUTPUT_VARIABLE string_defines
+    )
+
+    if(string_defines MATCHES "#define __GLIBCXX__")
+        # Allow -D_GLIBCXX_USE_CXX11_ABI=ON/OFF as argument to cmake
+        if(DEFINED _GLIBCXX_USE_CXX11_ABI)
+            if(_GLIBCXX_USE_CXX11_ABI)
+                set(${result} libstdc++11 PARENT_SCOPE)
+                return()
+            else()
+                set(${result} libstdc++ PARENT_SCOPE)
+                return()
+            endif()
+        endif()
+
+        if(string_defines MATCHES "#define _GLIBCXX_USE_CXX11_ABI 1\n")
+            set(${result} libstdc++11 PARENT_SCOPE)
+        else()
+            # Either the compiler is missing the define because it is old, and so
+            # it can't use the new abi, or the compiler was configured to use the
+            # old abi by the user or distro (e.g. devtoolset on RHEL/CentOS)
+            set(${result} libstdc++ PARENT_SCOPE)
+        endif()
+    else()
+        set(${result} libc++ PARENT_SCOPE)
+    endif()
+endfunction()
+
+function(conan_cmake_detect_vs_runtime result)
+    string(TOUPPER ${CMAKE_BUILD_TYPE} build_type)
+    set(variables CMAKE_CXX_FLAGS_${build_type} CMAKE_C_FLAGS_${build_type} CMAKE_CXX_FLAGS CMAKE_C_FLAGS)
+    foreach(variable ${variables})
+        if(NOT "${${variable}}" STREQUAL "")
+            string(REPLACE " " ";" flags ${${variable}})
+            foreach (flag ${flags})
+                if(${flag} STREQUAL "/MD" OR ${flag} STREQUAL "/MDd" OR ${flag} STREQUAL "/MT" OR ${flag} STREQUAL "/MTd")
+                    string(SUBSTRING ${flag} 1 -1 runtime)
+                    set(${result} ${runtime} PARENT_SCOPE)
+                    return()
+                endif()
+            endforeach()
+        endif()
+    endforeach()
+    if(${build_type} STREQUAL "DEBUG")
+        set(${result} "MDd" PARENT_SCOPE)
+    else()
+        set(${result} "MD" PARENT_SCOPE)
+    endif()
+endfunction()
+
+
+macro(parse_arguments)
+  set(options BASIC_SETUP CMAKE_TARGETS UPDATE KEEP_RPATHS NO_LOAD NO_OUTPUT_DIRS OUTPUT_QUIET NO_IMPORTS SKIP_STD)
+  set(oneValueArgs CONANFILE  ARCH BUILD_TYPE INSTALL_FOLDER CONAN_COMMAND)
+  set(multiValueArgs DEBUG_PROFILE RELEASE_PROFILE RELWITHDEBINFO_PROFILE MINSIZEREL_PROFILE
+                     PROFILE REQUIRES OPTIONS IMPORTS SETTINGS BUILD ENV GENERATORS PROFILE_AUTO
+                     INSTALL_ARGS CONFIGURATION_TYPES)
+  cmake_parse_arguments(ARGUMENTS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+endmacro()
+
+function(conan_cmake_install)
+    # Calls "conan install"
+    # Argument BUILD is equivalant to --build={missing, PkgName,...} or
+    # --build when argument is 'BUILD all' (which builds all packages from source)
+    # Argument CONAN_COMMAND, to specify the conan path, e.g. in case of running from source
+    # cmake does not identify conan as command, even if it is +x and it is in the path
+    parse_arguments(${ARGV})
+
+    if(CONAN_CMAKE_MULTI)
+        set(ARGUMENTS_GENERATORS ${ARGUMENTS_GENERATORS} cmake_multi)
+    else()
+        set(ARGUMENTS_GENERATORS ${ARGUMENTS_GENERATORS} cmake)
+    endif()
+
+    set(CONAN_BUILD_POLICY "")
+    foreach(ARG ${ARGUMENTS_BUILD})
+        if(${ARG} STREQUAL "all")
+            set(CONAN_BUILD_POLICY ${CONAN_BUILD_POLICY} --build)
+            break()
+        else()
+            set(CONAN_BUILD_POLICY ${CONAN_BUILD_POLICY} --build=${ARG})
+        endif()
+    endforeach()
+    if(ARGUMENTS_CONAN_COMMAND)
+       set(CONAN_CMD ${ARGUMENTS_CONAN_COMMAND})
+    else()
+        conan_check(REQUIRED)
+    endif()
+    set(CONAN_OPTIONS "")
+    if(ARGUMENTS_CONANFILE)
+      set(CONANFILE ${CMAKE_CURRENT_SOURCE_DIR}/${ARGUMENTS_CONANFILE})
+      # A conan file has been specified - apply specified options as well if provided
+      foreach(ARG ${ARGUMENTS_OPTIONS})
+          set(CONAN_OPTIONS ${CONAN_OPTIONS} -o=${ARG})
+      endforeach()
+    else()
+      set(CONANFILE ".")
+    endif()
+    if(ARGUMENTS_UPDATE)
+      set(CONAN_INSTALL_UPDATE --update)
+    endif()
+    if(ARGUMENTS_NO_IMPORTS)
+      set(CONAN_INSTALL_NO_IMPORTS --no-imports)
+    endif()
+    set(CONAN_INSTALL_FOLDER "")
+    if(ARGUMENTS_INSTALL_FOLDER)
+      set(CONAN_INSTALL_FOLDER -if=${ARGUMENTS_INSTALL_FOLDER})
+    endif()
+    foreach(ARG ${ARGUMENTS_GENERATORS})
+        set(CONAN_GENERATORS ${CONAN_GENERATORS} -g=${ARG})
+    endforeach()
+    foreach(ARG ${ARGUMENTS_ENV})
+        set(CONAN_ENV_VARS ${CONAN_ENV_VARS} -e=${ARG})
+    endforeach()
+    set(conan_args install ${CONANFILE} ${settings} ${CONAN_ENV_VARS} ${CONAN_GENERATORS} ${CONAN_BUILD_POLICY} ${CONAN_INSTALL_UPDATE} ${CONAN_INSTALL_NO_IMPORTS} ${CONAN_OPTIONS} ${CONAN_INSTALL_FOLDER} ${ARGUMENTS_INSTALL_ARGS})
+
+    string (REPLACE ";" " " _conan_args "${conan_args}")
+    message(STATUS "Conan executing: ${CONAN_CMD} ${_conan_args}")
+
+    if(ARGUMENTS_OUTPUT_QUIET)
+        execute_process(COMMAND ${CONAN_CMD} ${conan_args}
+                        RESULT_VARIABLE return_code
+                        OUTPUT_VARIABLE conan_output
+                        ERROR_VARIABLE conan_output
+                        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+    else()
+        execute_process(COMMAND ${CONAN_CMD} ${conan_args}
+                        RESULT_VARIABLE return_code
+                        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+    endif()
+
+    if(NOT "${return_code}" STREQUAL "0")
+      message(FATAL_ERROR "Conan install failed='${return_code}'")
+    endif()
+
+endfunction()
+
+
+function(conan_cmake_setup_conanfile)
+  parse_arguments(${ARGV})
+  if(ARGUMENTS_CONANFILE)
+    get_filename_component(_CONANFILE_NAME ${ARGUMENTS_CONANFILE} NAME)
+    # configure_file will make sure cmake re-runs when conanfile is updated
+    configure_file(${ARGUMENTS_CONANFILE} ${CMAKE_CURRENT_BINARY_DIR}/${_CONANFILE_NAME}.junk COPYONLY)
+    file(REMOVE ${CMAKE_CURRENT_BINARY_DIR}/${_CONANFILE_NAME}.junk)
+  else()
+    conan_cmake_generate_conanfile(${ARGV})
+  endif()
+endfunction()
+
+function(conan_cmake_generate_conanfile)
+  # Generate, writing in disk a conanfile.txt with the requires, options, and imports
+  # specified as arguments
+  # This will be considered as temporary file, generated in CMAKE_CURRENT_BINARY_DIR)
+  parse_arguments(${ARGV})
+  set(_FN "${CMAKE_CURRENT_BINARY_DIR}/conanfile.txt")
+
+  file(WRITE ${_FN} "[generators]\ncmake\n\n[requires]\n")
+  foreach(ARG ${ARGUMENTS_REQUIRES})
+    file(APPEND ${_FN} ${ARG} "\n")
+  endforeach()
+
+  file(APPEND ${_FN} ${ARG} "\n[options]\n")
+  foreach(ARG ${ARGUMENTS_OPTIONS})
+    file(APPEND ${_FN} ${ARG} "\n")
+  endforeach()
+
+  file(APPEND ${_FN} ${ARG} "\n[imports]\n")
+  foreach(ARG ${ARGUMENTS_IMPORTS})
+    file(APPEND ${_FN} ${ARG} "\n")
+  endforeach()
+endfunction()
+
+
+macro(conan_load_buildinfo)
+    if(CONAN_CMAKE_MULTI)
+      set(_CONANBUILDINFO conanbuildinfo_multi.cmake)
+    else()
+      set(_CONANBUILDINFO conanbuildinfo.cmake)
+    endif()
+    if(ARGUMENTS_INSTALL_FOLDER)
+        set(_CONANBUILDINFOFOLDER ${ARGUMENTS_INSTALL_FOLDER})
+    else()
+        set(_CONANBUILDINFOFOLDER ${CMAKE_CURRENT_BINARY_DIR})
+    endif()
+    # Checks for the existence of conanbuildinfo.cmake, and loads it
+    # important that it is macro, so variables defined at parent scope
+    if(EXISTS "${_CONANBUILDINFOFOLDER}/${_CONANBUILDINFO}")
+      message(STATUS "Conan: Loading ${_CONANBUILDINFO}")
+      include(${_CONANBUILDINFOFOLDER}/${_CONANBUILDINFO})
+    else()
+      message(FATAL_ERROR "${_CONANBUILDINFO} doesn't exist in ${CMAKE_CURRENT_BINARY_DIR}")
+    endif()
+endmacro()
+
+
+macro(conan_cmake_run)
+    parse_arguments(${ARGV})
+    
+    if(ARGUMENTS_CONFIGURATION_TYPES AND NOT CMAKE_CONFIGURATION_TYPES)
+        message(WARNING "CONFIGURATION_TYPES should only be specified for multi-configuration generators")
+    elseif(ARGUMENTS_CONFIGURATION_TYPES AND ARGUMENTS_BUILD_TYPE)
+        message(WARNING "CONFIGURATION_TYPES and BUILD_TYPE arguments should not be defined at the same time.")
+    endif()
+
+    if(CMAKE_CONFIGURATION_TYPES AND NOT CMAKE_BUILD_TYPE AND NOT CONAN_EXPORTED
+            AND NOT ARGUMENTS_BUILD_TYPE)
+        set(CONAN_CMAKE_MULTI ON)
+        if (NOT ARGUMENTS_CONFIGURATION_TYPES)
+            set(ARGUMENTS_CONFIGURATION_TYPES "Release;Debug")
+        endif()
+        message(STATUS "Conan: Using cmake-multi generator")
+    else()
+        set(CONAN_CMAKE_MULTI OFF)
+    endif()
+
+    if(NOT CONAN_EXPORTED)
+        conan_cmake_setup_conanfile(${ARGV})
+        if(CONAN_CMAKE_MULTI)
+            foreach(CMAKE_BUILD_TYPE ${ARGUMENTS_CONFIGURATION_TYPES})
+                set(ENV{CONAN_IMPORT_PATH} ${CMAKE_BUILD_TYPE})
+                conan_cmake_settings(settings ${ARGV})
+                conan_cmake_install(SETTINGS ${settings} ${ARGV})
+            endforeach()
+            set(CMAKE_BUILD_TYPE)
+        else()
+            conan_cmake_settings(settings ${ARGV})
+            conan_cmake_install(SETTINGS ${settings} ${ARGV})
+        endif()
+    endif()
+
+    if (NOT ARGUMENTS_NO_LOAD)
+      conan_load_buildinfo()
+    endif()
+
+    if(ARGUMENTS_BASIC_SETUP)
+        foreach(_option CMAKE_TARGETS KEEP_RPATHS NO_OUTPUT_DIRS SKIP_STD)
+            if(ARGUMENTS_${_option})
+                if(${_option} STREQUAL "CMAKE_TARGETS")
+                    list(APPEND _setup_options "TARGETS")
+                else()
+                    list(APPEND _setup_options ${_option})
+                endif()
+            endif()
+        endforeach()
+        conan_basic_setup(${_setup_options})
+    endif()
+endmacro()
+
+macro(conan_check)
+    # Checks conan availability in PATH
+    # Arguments REQUIRED and VERSION are optional
+    # Example usage:
+    #    conan_check(VERSION 1.0.0 REQUIRED)
+    message(STATUS "Conan: checking conan executable")
+    set(options REQUIRED)
+    set(oneValueArgs VERSION)
+    cmake_parse_arguments(CONAN "${options}" "${oneValueArgs}" "" ${ARGN})
+
+    find_program(CONAN_CMD conan)
+    if(NOT CONAN_CMD AND CONAN_REQUIRED)
+        message(FATAL_ERROR "Conan executable not found!")
+    endif()
+    message(STATUS "Conan: Found program ${CONAN_CMD}")
+    execute_process(COMMAND ${CONAN_CMD} --version
+                    OUTPUT_VARIABLE CONAN_VERSION_OUTPUT
+                    ERROR_VARIABLE CONAN_VERSION_OUTPUT)
+    message(STATUS "Conan: Version found ${CONAN_VERSION_OUTPUT}")
+
+    if(DEFINED CONAN_VERSION)
+        string(REGEX MATCH ".*Conan version ([0-9]+\.[0-9]+\.[0-9]+)" FOO
+            "${CONAN_VERSION_OUTPUT}")
+        if(${CMAKE_MATCH_1} VERSION_LESS ${CONAN_VERSION})
+            message(FATAL_ERROR "Conan outdated. Installed: ${CMAKE_MATCH_1}, \
+                required: ${CONAN_VERSION}. Consider updating via 'pip \
+                install conan==${CONAN_VERSION}'.")
+        endif()
+    endif()
+endmacro()
+
+function(conan_add_remote)
+    # Adds a remote
+    # Arguments URL and NAME are required, INDEX and COMMAND are optional
+    # Example usage:
+    #    conan_add_remote(NAME bincrafters INDEX 1
+    #       URL https://api.bintray.com/conan/bincrafters/public-conan)
+    set(oneValueArgs URL NAME INDEX COMMAND)
+    cmake_parse_arguments(CONAN "" "${oneValueArgs}" "" ${ARGN})
+
+    if(DEFINED CONAN_INDEX)
+        set(CONAN_INDEX_ARG "-i ${CONAN_INDEX}")
+    endif()
+    if(CONAN_COMMAND)
+       set(CONAN_CMD ${CONAN_COMMAND})
+    else()
+        conan_check(REQUIRED)
+    endif()
+    message(STATUS "Conan: Adding ${CONAN_NAME} remote repository (${CONAN_URL})")
+    execute_process(COMMAND ${CONAN_CMD} remote add ${CONAN_NAME} ${CONAN_URL}
+      ${CONAN_INDEX_ARG} -f)
+endfunction()
+
+macro(conan_config_install)
+    # install a full configuration from a local or remote zip file
+    # Argument ITEM is required, arguments TYPE, SOURCE, TARGET and VERIFY_SSL are optional
+    # Example usage:
+    #    conan_config_install(ITEM https://github.com/conan-io/cmake-conan.git
+    #       TYPE git SOURCE source-folder TARGET target-folder VERIFY_SSL false)
+    set(oneValueArgs ITEM TYPE SOURCE TARGET VERIFY_SSL)
+    set(multiValueArgs ARGS)
+    cmake_parse_arguments(CONAN "" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+    set(CONAN_CONFIG_INSTALL_ARGS "")
+
+    find_program(CONAN_CMD conan)
+    if(NOT CONAN_CMD AND CONAN_REQUIRED)
+        message(FATAL_ERROR "Conan executable not found!")
+    endif()
+
+    if(DEFINED CONAN_VERIFY_SSL)
+        set(CONAN_CONFIG_INSTALL_ARGS "${CONAN_CONFIG_INSTALL_ARGS} --verify-ssl ${CONAN_VERIFY_SSL}")
+    endif()
+
+    if(DEFINED CONAN_TYPE)
+        set(CONAN_CONFIG_INSTALL_ARGS "${CONAN_CONFIG_INSTALL_ARGS} --type ${CONAN_TYPE}")
+    endif()
+
+    if(DEFINED CONAN_ARGS)
+        set(CONAN_CONFIG_INSTALL_ARGS "${CONAN_CONFIG_INSTALL_ARGS} --args \"${CONAN_ARGS}\"")
+    endif()
+
+    if(DEFINED CONAN_SOURCE)
+        set(CONAN_CONFIG_INSTALL_ARGS "${CONAN_CONFIG_INSTALL_ARGS} --source-folder ${CONAN_SOURCE}")
+    endif()
+
+    if(DEFINED CONAN_TARGET)
+        set(CONAN_CONFIG_INSTALL_ARGS "${CONAN_CONFIG_INSTALL_ARGS} --target-folder ${CONAN_TARGET}")
+    endif()
+
+    message(STATUS "Conan: Installing config from ${CONAN_ITEM}")
+    execute_process(COMMAND ${CONAN_CMD} config install ${CONAN_CONFIG_INSTALL_ARGS} ${CONAN_ITEM})
+endmacro()
diff --git a/src/conanfile.py b/src/conanfile.py
new file mode 100644
index 0000000..3678ffb
--- /dev/null
+++ b/src/conanfile.py
@@ -0,0 +1,18 @@
+#
+from conans import ConanFile
+
+
+class odaServerConan(ConanFile):
+    settings = "os", "compiler", "build_type", "arch"
+
+    def requirements(self):
+        # Core dependencies
+        #self.requires("zlib/1.2.11@odant/stable")
+        self.requires("openssl/1.1.0l+2@odant/stable")
+        self.requires("pcre/8.43+5@odant/stable")
+        self.requires("cyrus-sasl/2.1.26+0@odant/testing")
+
+    def imports(self):
+        self.copy("*.dll", dst="bin", src="bin")
+        self.copy("*.pdb", dst="bin", src="bin")
+        self.copy("*.so*", dst="bin", src="lib")
diff --git a/src/include/CMakeLists.txt b/src/include/CMakeLists.txt
new file mode 100644
index 0000000..cfbfb9e
--- /dev/null
+++ b/src/include/CMakeLists.txt
@@ -0,0 +1,30 @@
+###############################################################
+include(PrepareConfigureFile)
+prepare_configure_file(${CMAKE_SOURCE_DIR}/include/portable.hin)
+prepare_configure_file(${CMAKE_SOURCE_DIR}/include/lber_types.hin)
+prepare_configure_file(${CMAKE_SOURCE_DIR}/include/ldap_config.hin)
+prepare_configure_file(${CMAKE_SOURCE_DIR}/include/ldap_features.hin)
+
+configure_file(${CMAKE_BINARY_DIR}/portable.h.cmake portable.h)
+configure_file(${CMAKE_BINARY_DIR}/lber_types.h.cmake lber_types.h)
+configure_file(${CMAKE_BINARY_DIR}/ldap_config.h.cmake ldap_config.h)
+configure_file(${CMAKE_BINARY_DIR}/ldap_features.h.cmake ldap_features.h)
+
+set(ldap_HDRS
+# generated headers:
+    ${CMAKE_CURRENT_BINARY_DIR}/portable.h
+    ${CMAKE_CURRENT_BINARY_DIR}/lber_types.h
+    ${CMAKE_CURRENT_BINARY_DIR}/ldap_config.h
+    ${CMAKE_CURRENT_BINARY_DIR}/ldap_features.h
+
+# non-generated headers:
+#    lber.h
+#    ldap.h
+#    ldap_cdefs.h
+#    ldap_schema.h
+#    ldap_utf8.h
+#    slapi-plugin.h
+#    ldif.h
+)
+
+install(FILES ${ldap_HDRS} DESTINATION include)
diff --git a/src/include/ac/regex.h b/src/include/ac/regex.h
index ad9ae60..41fdaef 100644
--- a/src/include/ac/regex.h
+++ b/src/include/ac/regex.h
@@ -28,6 +28,9 @@
  */
 #error "No POSIX REGEX available."
 
+#elif HAVE_PCREPOSIX_H
+	/* system has pcre pcreposix.h */
+#	include <pcreposix.h>
 #elif HAVE_GNUREGEX_H
 	/* system has GNU gnuregex.h */
 #	include <gnuregex.h>
diff --git a/src/include/ac/socket.h b/src/include/ac/socket.h
index 95f4434..0059542 100644
--- a/src/include/ac/socket.h
+++ b/src/include/ac/socket.h
@@ -98,9 +98,11 @@
 #		define tcp_close( s )		closesocket( s )
 #	endif
 
+#if _MSC_VER < 1600
 #define EWOULDBLOCK WSAEWOULDBLOCK
 #define EINPROGRESS WSAEINPROGRESS
 #define ETIMEDOUT	WSAETIMEDOUT
+#endif
 
 #undef	sock_errno
 #undef	sock_errstr
diff --git a/src/include/ac/time.h b/src/include/ac/time.h
index f2cb70f..0f2f87e 100644
--- a/src/include/ac/time.h
+++ b/src/include/ac/time.h
@@ -29,4 +29,7 @@
 # include <time.h>
 #endif
 
+#ifdef _WIN32
+#    include <winsock2.h> // for struct timeval
+#endif
 #endif /* _AC_TIME_H */
diff --git a/src/include/getopt-compat.h b/src/include/getopt-compat.h
index ca2aca1..b246172 100644
--- a/src/include/getopt-compat.h
+++ b/src/include/getopt-compat.h
@@ -32,7 +32,9 @@ LDAP_BEGIN_DECL
 #define getopt lutil_getopt
 
 LDAP_LUTIL_V (char *) optarg;
-LDAP_LUTIL_V (int) optind, opterr, optopt;
+LDAP_LUTIL_V (int) optind;
+LDAP_LUTIL_V (int) opterr;
+LDAP_LUTIL_V (int) optopt;
 LDAP_LUTIL_F (int) getopt LDAP_P(( int, char * const [], const char *));
 
 LDAP_END_DECL
diff --git a/src/include/ldap_cdefs.h b/src/include/ldap_cdefs.h
index 4992302..affc00e 100644
--- a/src/include/ldap_cdefs.h
+++ b/src/include/ldap_cdefs.h
@@ -127,68 +127,99 @@
  */
 
 /* LBER library */
-#if defined(_WIN32) && \
-    ((defined(LDAP_LIBS_DYNAMIC) && !defined(LBER_LIBRARY)) || \
-     (!defined(LDAP_LIBS_DYNAMIC) && defined(SLAPD_IMPORT)))
+#if defined(_WIN32) && defined(LDAP_LIBS_DYNAMIC)
+#if !defined(LBER_LIBRARY)
 #	define LBER_F(type)		extern __declspec(dllimport) type
 #	define LBER_V(type)		extern __declspec(dllimport) type
 #else
+#	define LBER_F(type)		extern __declspec(dllexport) type
+#	define LBER_V(type)		extern __declspec(dllexport) type
+#endif
+#else
 #	define LBER_F(type)		extern type
 #	define LBER_V(type)		extern type
 #endif
 
 /* LDAP library */
-#if defined(_WIN32) && \
-    ((defined(LDAP_LIBS_DYNAMIC) && !defined(LDAP_LIBRARY)) || \
-     (!defined(LDAP_LIBS_DYNAMIC) && defined(SLAPD_IMPORT)))
+#if defined(_WIN32) && defined(LDAP_LIBS_DYNAMIC)
+#if !defined(LDAP_LIBRARY)
 #	define LDAP_F(type)		extern __declspec(dllimport) type
 #	define LDAP_V(type)		extern __declspec(dllimport) type
 #else
+#	define LDAP_F(type)		extern __declspec(dllexport) type
+#	define LDAP_V(type)		extern __declspec(dllexport) type
+#endif
+#else
 #	define LDAP_F(type)		extern type
 #	define LDAP_V(type)		extern type
 #endif
 
 /* AVL library */
-#if defined(_WIN32) && defined(SLAPD_IMPORT)
+#if defined(_WIN32) && defined(LDAP_LIBS_DYNAMIC)
+#if !defined(LUTIL_LIBRARY)
 #	define LDAP_AVL_F(type)		extern __declspec(dllimport) type
 #	define LDAP_AVL_V(type)		extern __declspec(dllimport) type
 #else
+#	define LDAP_AVL_F(type)		extern __declspec(dllexport) type
+#	define LDAP_AVL_V(type)		extern __declspec(dllexport) type
+#endif
+#else
 #	define LDAP_AVL_F(type)		extern type
 #	define LDAP_AVL_V(type)		extern type
 #endif
 
 /* LDIF library */
-#if defined(_WIN32) && defined(SLAPD_IMPORT)
-#	define LDAP_LDIF_F(type)	extern __declspec(dllimport) type
-#	define LDAP_LDIF_V(type)	extern __declspec(dllimport) type
+#if defined(_WIN32) && defined(LDAP_LIBS_DYNAMIC)
+#if !defined(LDAP_LIBRARY)
+#	define LDAP_LDIF_F(type)		extern __declspec(dllimport) type
+#	define LDAP_LDIF_V(type)		extern __declspec(dllimport) type
+#else
+#	define LDAP_LDIF_F(type)		extern __declspec(dllexport) type
+#	define LDAP_LDIF_V(type)		extern __declspec(dllexport) type
+#endif
 #else
 #	define LDAP_LDIF_F(type)	extern type
 #	define LDAP_LDIF_V(type)	extern type
 #endif
 
 /* LUNICODE library */
-#if defined(_WIN32) && defined(SLAPD_IMPORT)
+#if defined(_WIN32) && defined(LDAP_LIBS_DYNAMIC)
+#if !defined(LUNICODE_LIBRARY)
 #	define LDAP_LUNICODE_F(type)	extern __declspec(dllimport) type
 #	define LDAP_LUNICODE_V(type)	extern __declspec(dllimport) type
 #else
+#	define LDAP_LUNICODE_F(type)	extern __declspec(dllexport) type
+#	define LDAP_LUNICODE_V(type)	extern __declspec(dllexport) type
+#endif
+#else
 #	define LDAP_LUNICODE_F(type)	extern type
 #	define LDAP_LUNICODE_V(type)	extern type
 #endif
 
 /* LUTIL library */
-#if defined(_WIN32) && defined(SLAPD_IMPORT)
+#if defined(_WIN32) && defined(LDAP_LIBS_DYNAMIC)
+#if !defined(LUTIL_LIBRARY)
 #	define LDAP_LUTIL_F(type)	extern __declspec(dllimport) type
 #	define LDAP_LUTIL_V(type)	extern __declspec(dllimport) type
 #else
+#	define LDAP_LUTIL_F(type)	extern __declspec(dllexport) type
+#	define LDAP_LUTIL_V(type)	extern __declspec(dllexport) type
+#endif
+#else
 #	define LDAP_LUTIL_F(type)	extern type
 #	define LDAP_LUTIL_V(type)	extern type
 #endif
 
 /* REWRITE library */
-#if defined(_WIN32) && defined(SLAPD_IMPORT)
+#if defined(_WIN32) && defined(LDAP_LIBS_DYNAMIC)
+#if !defined(REWRITE_LIBRARY)
 #	define LDAP_REWRITE_F(type)	extern __declspec(dllimport) type
 #	define LDAP_REWRITE_V(type)	extern __declspec(dllimport) type
 #else
+#	define LDAP_REWRITE_F(type)	extern __declspec(dllexport) type
+#	define LDAP_REWRITE_V(type)	extern __declspec(dllexport) type
+#endif
+#else
 #	define LDAP_REWRITE_F(type)	extern type
 #	define LDAP_REWRITE_V(type)	extern type
 #endif
diff --git a/src/include/ldap_log.h b/src/include/ldap_log.h
index f993160..bc2f069 100644
--- a/src/include/ldap_log.h
+++ b/src/include/ldap_log.h
@@ -132,12 +132,12 @@ LDAP_BEGIN_DECL
      * a 'proper' dllimport.
      */
 #ifndef ldap_debug
-extern int	ldap_debug;
+LDAP_REWRITE_V(int) ldap_debug;
 #endif /* !ldap_debug */
 
 #ifdef LDAP_SYSLOG
-extern int	ldap_syslog;
-extern int	ldap_syslog_level;
+LDAP_REWRITE_V(int) ldap_syslog;
+LDAP_REWRITE_V(int) ldap_syslog_level;
 
 #ifdef HAVE_EBCDIC
 #define syslog	eb_syslog
@@ -243,9 +243,9 @@ extern void eb_syslog(int pri, const char *fmt, ...);
 #endif /* ! LDAP_DEBUG */
 
 /* Actually now in liblber/debug.c */
-LDAP_LUTIL_F(int) lutil_debug_file LDAP_P(( FILE *file ));
+LBER_F(int) lutil_debug_file LDAP_P(( FILE *file ));
 
-LDAP_LUTIL_F(void) lutil_debug LDAP_P((
+LBER_F(void) lutil_debug LDAP_P((
 	int debug, int level,
 	const char* fmt, ... )) LDAP_GCCATTR((format(printf, 3, 4)));
 
diff --git a/src/include/portable.hin b/src/include/portable.hin
index 859067c..6a14c9e 100644
--- a/src/include/portable.hin
+++ b/src/include/portable.hin
@@ -463,6 +463,9 @@
 /* Define to 1 if you have the <regex.h> header file. */
 #undef HAVE_REGEX_H
 
+/* Define to 1 if you have the <pcreposix.h> header file. */
+#undef HAVE_PCREPOSIX_H
+
 /* Define to 1 if you have the <resolv.h> header file. */
 #undef HAVE_RESOLV_H
 
@@ -858,6 +861,15 @@
 /* Patch */
 #undef LDAP_VENDOR_VERSION_PATCH
 
+/* Patch */
+#undef LDAP_VENDOR_VERSION_BUILD
+
+/* RC Versions */
+#undef LDAP_RC_FILE_VERSION
+#undef LDAP_RC_PRODUCT_VERSION
+#undef LDAP_RC_FILE_VERSION_STR
+#undef LDAP_RC_PRODUCT_VERSION_STR
+
 /* define if memcmp is not 8-bit clean or is otherwise broken */
 #undef NEED_MEMCMP_REPLACEMENT
 
@@ -1105,18 +1117,12 @@
 /* Define to `int' if <signal.h> does not define. */
 #undef sig_atomic_t
 
-/* Define to `unsigned' if <sys/types.h> does not define. */
-#undef size_t
-
 /* define to snprintf routine */
 #undef snprintf
 
 /* Define like ber_socklen_t if <sys/socket.h> does not define. */
 #undef socklen_t
 
-/* Define to `signed int' if <sys/types.h> does not define. */
-#undef ssize_t
-
 /* Define to `int' if <sys/types.h> doesn't define. */
 #undef uid_t
 
@@ -1165,6 +1171,10 @@
 #define vsprintf ber_pvt_vsprintf
 #endif
 
+#ifdef _WIN32
+#    include <windows.h>
+#endif
+
 #include "ac/fdset.h"
 
 #include "ldap_cdefs.h"
diff --git a/src/libraries/CMakeLists.txt b/src/libraries/CMakeLists.txt
new file mode 100644
index 0000000..208d482
--- /dev/null
+++ b/src/libraries/CMakeLists.txt
@@ -0,0 +1,7 @@
+include_directories(${CMAKE_SOURCE_DIR}/include ${CMAKE_BINARY_DIR}/include)
+add_subdirectory(liblutil)
+add_subdirectory(liblber)
+add_subdirectory(liblunicode)
+add_subdirectory(libldap)
+add_subdirectory(libldap_r)
+add_subdirectory(librewrite)
diff --git a/src/libraries/liblber/CMakeLists.txt b/src/libraries/liblber/CMakeLists.txt
new file mode 100644
index 0000000..93e3880
--- /dev/null
+++ b/src/libraries/liblber/CMakeLists.txt
@@ -0,0 +1,28 @@
+set(lber_SRCS
+    assert.c
+    decode.c
+    encode.c
+    io.c
+    bprint.c
+    debug.c
+    memory.c
+    options.c
+    sockbuf.c
+)
+
+if(WIN32)
+    list(APPEND lber_SRCS nt_err.c)
+    if("${LDAP_SHARED}" STREQUAL "SHARED")
+        list(APPEND lber_SRCS lber.rc)
+    endif()
+endif(WIN32)
+if(UNIX)
+    list(APPEND lber_SRCS stdio.c)
+endif(UNIX)
+
+add_library(lber ${LDAP_SHARED} ${lber_SRCS})
+if(WIN32)
+    target_link_libraries(lber ws2_32)
+endif(WIN32)
+set_target_properties(lber PROPERTIES DEFINE_SYMBOL LBER_LIBRARY)
+install(TARGETS lber ${INSTALL_TARGETS_DEFAULT_ARGS})
diff --git a/src/libraries/liblber/lber.rc b/src/libraries/liblber/lber.rc
new file mode 100644
index 0000000..214798c
--- /dev/null
+++ b/src/libraries/liblber/lber.rc
@@ -0,0 +1,45 @@
+#include <windows.h>
+#include "portable.h"
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION LDAP_RC_FILE_VERSION
+ PRODUCTVERSION LDAP_RC_PRODUCT_VERSION
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904e2"
+        BEGIN
+            VALUE "Comments", "OpenLDAP Software is an open source implementation of the Lightweight Directory Access Protocol.\0"
+            VALUE "CompanyName", "OpenLDAP Foundation\0"
+            VALUE "FileDescription", "OpenLDAP library\0"
+            VALUE "FileVersion", LDAP_RC_FILE_VERSION_STR
+            VALUE "InternalName", "lber\0"
+            VALUE "LegalCopyright", "The OpenLDAP Public License\0"
+            VALUE "LegalTrademarks", "See http://www.openldap.org/software/release/license.html\0"
+            VALUE "OriginalFilename", "lber.dll\0"
+            VALUE "PrivateBuild", "\0"
+            VALUE "ProductName", "OpenLDAP library\0"
+            VALUE "ProductVersion", LDAP_RC_PRODUCT_VERSION_STR
+            VALUE "SpecialBuild", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1250
+    END
+END
+
diff --git a/src/libraries/liblber/nt_err.c b/src/libraries/liblber/nt_err.c
index bfccef1..3372f2d 100644
--- a/src/libraries/liblber/nt_err.c
+++ b/src/libraries/liblber/nt_err.c
@@ -15,6 +15,9 @@
 
 #include "portable.h"
 
+LBER_F( char * )
+ber_pvt_wsa_err2string LDAP_P((int));
+
 #ifdef HAVE_WINSOCK2
 #include <winsock2.h>
 #elif defined(HAVE_WINSOCK)
diff --git a/src/libraries/libldap/CMakeLists.txt b/src/libraries/libldap/CMakeLists.txt
new file mode 100644
index 0000000..a0d86bb
--- /dev/null
+++ b/src/libraries/libldap/CMakeLists.txt
@@ -0,0 +1,79 @@
+set(ldap_SRCS
+    bind.c
+    open.c
+    result.c
+    error.c
+    compare.c
+    search.c
+    controls.c
+    messages.c
+    references.c
+    extended.c
+    cyrus.c
+    modify.c
+    add.c
+    modrdn.c
+    delete.c
+    abandon.c
+    sasl.c
+    gssapi.c
+    sbind.c
+    unbind.c
+    cancel.c
+    filter.c
+    free.c
+    sort.c
+    passwd.c
+    whoami.c
+    getdn.c
+    getentry.c
+    getattr.c
+    getvalues.c
+    addentry.c
+    request.c
+    os-ip.c
+    url.c
+    pagectrl.c
+    sortctrl.c
+    vlvctrl.c
+    init.c
+    options.c
+    print.c
+    string.c
+    util-int.c
+    schema.c
+    charray.c
+    os-local.c
+    dnssrv.c
+    utf-8.c
+    utf-8-conv.c
+    tls2.c
+    tls_o.c
+    tls_g.c
+    tls_m.c
+    turn.c
+    ppolicy.c
+    dds.c
+    txn.c
+    ldap_sync.c
+    stctrl.c
+    assertion.c
+    deref.c
+    ldif.c
+    fetch.c
+)
+
+if(WIN32 AND "${LDAP_SHARED}" STREQUAL "SHARED")
+    list(APPEND ldap_SRCS ldap.rc)
+endif()
+
+add_library(ldap ${LDAP_SHARED} ${ldap_SRCS})
+set_target_properties(ldap PROPERTIES DEFINE_SYMBOL LDAP_LIBRARY)
+target_link_libraries(ldap lber)
+if(${SASL2_FOUND})
+    target_link_libraries (ldap ${SASL2_LIBRARIES})
+endif()
+if(${OPENSSL_FOUND})
+    target_link_libraries (ldap ${OPENSSL_LIBRARIES})
+endif()
+install(TARGETS ldap ${INSTALL_TARGETS_DEFAULT_ARGS})
diff --git a/src/libraries/libldap/ldap.rc b/src/libraries/libldap/ldap.rc
new file mode 100644
index 0000000..0169c9d
--- /dev/null
+++ b/src/libraries/libldap/ldap.rc
@@ -0,0 +1,45 @@
+#include <windows.h>
+#include "portable.h"
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION LDAP_RC_FILE_VERSION
+ PRODUCTVERSION LDAP_RC_PRODUCT_VERSION
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904e2"
+        BEGIN
+            VALUE "Comments", "OpenLDAP Software is an open source implementation of the Lightweight Directory Access Protocol.\0"
+            VALUE "CompanyName", "OpenLDAP Foundation\0"
+            VALUE "FileDescription", "OpenLDAP library\0"
+            VALUE "FileVersion", LDAP_RC_FILE_VERSION_STR
+            VALUE "InternalName", "lbap\0"
+            VALUE "LegalCopyright", "The OpenLDAP Public License\0"
+            VALUE "LegalTrademarks", "See http://www.openldap.org/software/release/license.html\0"
+            VALUE "OriginalFilename", "ldap.dll\0"
+            VALUE "PrivateBuild", "\0"
+            VALUE "ProductName", "OpenLDAP library\0"
+            VALUE "ProductVersion", LDAP_RC_PRODUCT_VERSION_STR
+            VALUE "SpecialBuild", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1250
+    END
+END
+
diff --git a/src/libraries/libldap/ldif.c b/src/libraries/libldap/ldif.c
index 8b20c2a..0c24470 100644
--- a/src/libraries/libldap/ldif.c
+++ b/src/libraries/libldap/ldif.c
@@ -38,12 +38,12 @@
 #include <ac/socket.h>
 #include <ac/time.h>
 
-int ldif_debug = 0;
-
 #include "ldap_log.h"
 #include "lber_pvt.h"
 #include "ldif.h"
 
+int ldif_debug = 0;
+
 #define RIGHT2			0x03
 #define RIGHT4			0x0f
 #define CONTINUED_LINE_MARKER	'\r'
diff --git a/src/libraries/libldap/tls_o.c b/src/libraries/libldap/tls_o.c
index 2025c9f..a9c8eb6 100644
--- a/src/libraries/libldap/tls_o.c
+++ b/src/libraries/libldap/tls_o.c
@@ -54,6 +54,9 @@
 typedef SSL_CTX tlso_ctx;
 typedef SSL tlso_session;
 
+static BIO_METHOD * tlso_bio_method = NULL;
+static BIO_METHOD * tlso_bio_setup( void );
+
 static int  tlso_opt_trace = 1;
 
 static void tlso_report_error( void );
@@ -113,6 +116,43 @@ static void tlso_thr_init( void ) {}
 #endif
 #endif /* OpenSSL 1.1 */
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+/*
+ * OpenSSL 1.1 API and later makes the BIO method concrete types internal.
+ */
+
+static const BIO_METHOD *
+BIO_meth_new( int type, const char *name )
+{
+	BIO_METHOD *method = LDAP_MALLOC( sizeof(BIO_METHOD) );
+	memset( method, 0, sizeof(BIO_METHOD) );
+
+	method->type = type;
+	method->name = name;
+
+	return method;
+}
+
+static void
+BIO_meth_free( BIO_METHOD *meth )
+{
+	if ( meth == NULL ) {
+		return;
+	}
+
+	LDAP_FREE( meth );
+}
+
+#define BIO_meth_set_write(m, f) (m)->bwrite = (f)
+#define BIO_meth_set_read(m, f) (m)->bread = (f)
+#define BIO_meth_set_puts(m, f) (m)->bputs = (f)
+#define BIO_meth_set_gets(m, f) (m)->bgets = (f)
+#define BIO_meth_set_ctrl(m, f) (m)->ctrl = (f)
+#define BIO_meth_set_create(m, f) (m)->create = (f)
+#define BIO_meth_set_destroy(m, f) (m)->destroy = (f)
+
+#endif /* OpenSSL 1.1 */
+
 static STACK_OF(X509_NAME) *
 tlso_ca_list( char * bundle, char * dir )
 {
@@ -146,6 +186,7 @@ static int
 tlso_init( void )
 {
 	struct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   
+#ifdef HAVE_TLS
 #ifdef HAVE_EBCDIC
 	{
 		char *file = LDAP_STRDUP( lo->ldo_tls_randfile );
@@ -156,6 +197,7 @@ tlso_init( void )
 #else
 	(void) tlso_seed_PRNG( lo->ldo_tls_randfile );
 #endif
+#endif /* HAVE_TLS */
 
 #if OPENSSL_VERSION_NUMBER < 0x10100000
 	SSL_load_error_strings();
@@ -167,7 +209,8 @@ tlso_init( void )
 
 	/* FIXME: mod_ssl does this */
 	X509V3_add_standard_extensions();
-
+    tlso_bio_method = tlso_bio_setup();
+    
 	return 0;
 }
 
@@ -178,6 +221,7 @@ static void
 tlso_destroy( void )
 {
 	struct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   
+    BIO_meth_free( tlso_bio_method );
 
 #if OPENSSL_VERSION_NUMBER < 0x10100000
 	EVP_cleanup();
@@ -822,33 +866,21 @@ tlso_bio_puts( BIO *b, const char *str )
 	return tlso_bio_write( b, str, strlen( str ) );
 }
 
-#if OPENSSL_VERSION_NUMBER >= 0x10100000
-struct bio_method_st {
-    int type;
-    const char *name;
-    int (*bwrite) (BIO *, const char *, int);
-    int (*bread) (BIO *, char *, int);
-    int (*bputs) (BIO *, const char *);
-    int (*bgets) (BIO *, char *, int);
-    long (*ctrl) (BIO *, int, long, void *);
-    int (*create) (BIO *);
-    int (*destroy) (BIO *);
-    long (*callback_ctrl) (BIO *, int, bio_info_cb *);
-};
-#endif
-
-static BIO_METHOD tlso_bio_method =
+static BIO_METHOD *
+tlso_bio_setup( void )
 {
-	( 100 | 0x400 ),		/* it's a source/sink BIO */
-	"sockbuf glue",
-	tlso_bio_write,
-	tlso_bio_read,
-	tlso_bio_puts,
-	tlso_bio_gets,
-	tlso_bio_ctrl,
-	tlso_bio_create,
-	tlso_bio_destroy
-};
+	/* it's a source/sink BIO */
+	BIO_METHOD * method = BIO_meth_new( 100 | 0x400, "sockbuf glue" );
+	BIO_meth_set_write( method, tlso_bio_write );
+	BIO_meth_set_read( method, tlso_bio_read );
+	BIO_meth_set_puts( method, tlso_bio_puts );
+	BIO_meth_set_gets( method, tlso_bio_gets );
+	BIO_meth_set_ctrl( method, tlso_bio_ctrl );
+	BIO_meth_set_create( method, tlso_bio_create );
+	BIO_meth_set_destroy( method, tlso_bio_destroy );
+
+	return method;
+}
 
 static int
 tlso_sb_setup( Sockbuf_IO_Desc *sbiod, void *arg )
@@ -865,7 +897,7 @@ tlso_sb_setup( Sockbuf_IO_Desc *sbiod, void *arg )
 	
 	p->session = arg;
 	p->sbiod = sbiod;
-	bio = BIO_new( &tlso_bio_method );
+	bio = BIO_new( tlso_bio_method );
 	BIO_set_data( bio, p );
 	SSL_set_bio( p->session, bio, bio );
 	sbiod->sbiod_pvt = p;
@@ -1187,9 +1219,6 @@ tlso_seed_PRNG( const char *randfile )
 		 */
 		randfile = RAND_file_name( buffer, sizeof( buffer ) );
 
-	} else if (RAND_egd(randfile) > 0) {
-		/* EGD socket */
-		return 0;
 	}
 
 	if (randfile == NULL) {
diff --git a/src/libraries/libldap/tls_o.c.orig_ b/src/libraries/libldap/tls_o.c.orig_
new file mode 100644
index 0000000..2025c9f
--- /dev/null
+++ b/src/libraries/libldap/tls_o.c.orig_
@@ -0,0 +1,1254 @@
+/* tls_o.c - Handle tls/ssl using OpenSSL */
+/* $OpenLDAP$ */
+/* This work is part of OpenLDAP Software <http://www.openldap.org/>.
+ *
+ * Copyright 2008-2017 The OpenLDAP Foundation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted only as authorized by the OpenLDAP
+ * Public License.
+ *
+ * A copy of this license is available in the file LICENSE in the
+ * top-level directory of the distribution or, alternatively, at
+ * <http://www.OpenLDAP.org/license.html>.
+ */
+/* ACKNOWLEDGEMENTS: Rewritten by Howard Chu
+ */
+
+#include "portable.h"
+
+#ifdef HAVE_OPENSSL
+
+#include "ldap_config.h"
+
+#include <stdio.h>
+
+#include <ac/stdlib.h>
+#include <ac/errno.h>
+#include <ac/socket.h>
+#include <ac/string.h>
+#include <ac/ctype.h>
+#include <ac/time.h>
+#include <ac/unistd.h>
+#include <ac/param.h>
+#include <ac/dirent.h>
+
+#include "ldap-int.h"
+#include "ldap-tls.h"
+
+#ifdef HAVE_OPENSSL_SSL_H
+#include <openssl/ssl.h>
+#include <openssl/x509v3.h>
+#include <openssl/err.h>
+#include <openssl/rand.h>
+#include <openssl/safestack.h>
+#elif defined( HAVE_SSL_H )
+#include <ssl.h>
+#endif
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000
+#define ASN1_STRING_data(x)	ASN1_STRING_get0_data(x)
+#endif
+
+typedef SSL_CTX tlso_ctx;
+typedef SSL tlso_session;
+
+static int  tlso_opt_trace = 1;
+
+static void tlso_report_error( void );
+
+static void tlso_info_cb( const SSL *ssl, int where, int ret );
+static int tlso_verify_cb( int ok, X509_STORE_CTX *ctx );
+static int tlso_verify_ok( int ok, X509_STORE_CTX *ctx );
+static int tlso_seed_PRNG( const char *randfile );
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+/*
+ * OpenSSL 1.1 API and later has new locking code
+*/
+static RSA * tlso_tmp_rsa_cb( SSL *ssl, int is_export, int key_length );
+
+#ifdef LDAP_R_COMPILE
+/*
+ * provide mutexes for the OpenSSL library.
+ */
+static ldap_pvt_thread_mutex_t	tlso_mutexes[CRYPTO_NUM_LOCKS];
+
+static void tlso_locking_cb( int mode, int type, const char *file, int line )
+{
+	if ( mode & CRYPTO_LOCK ) {
+		ldap_pvt_thread_mutex_lock( &tlso_mutexes[type] );
+	} else {
+		ldap_pvt_thread_mutex_unlock( &tlso_mutexes[type] );
+	}
+}
+
+static unsigned long tlso_thread_self( void )
+{
+	/* FIXME: CRYPTO_set_id_callback only works when ldap_pvt_thread_t
+	 * is an integral type that fits in an unsigned long
+	 */
+
+	/* force an error if the ldap_pvt_thread_t type is too large */
+	enum { ok = sizeof( ldap_pvt_thread_t ) <= sizeof( unsigned long ) };
+	typedef struct { int dummy: ok ? 1 : -1; } Check[ok ? 1 : -1];
+
+	return (unsigned long) ldap_pvt_thread_self();
+}
+
+static void tlso_thr_init( void )
+{
+	int i;
+
+	for( i=0; i< CRYPTO_NUM_LOCKS ; i++ ) {
+		ldap_pvt_thread_mutex_init( &tlso_mutexes[i] );
+	}
+	CRYPTO_set_locking_callback( tlso_locking_cb );
+	CRYPTO_set_id_callback( tlso_thread_self );
+}
+#endif /* LDAP_R_COMPILE */
+#else
+#ifdef LDAP_R_COMPILE
+static void tlso_thr_init( void ) {}
+#endif
+#endif /* OpenSSL 1.1 */
+
+static STACK_OF(X509_NAME) *
+tlso_ca_list( char * bundle, char * dir )
+{
+	STACK_OF(X509_NAME) *ca_list = NULL;
+
+	if ( bundle ) {
+		ca_list = SSL_load_client_CA_file( bundle );
+	}
+#if defined(HAVE_DIRENT_H) || defined(dirent)
+	if ( dir ) {
+		int freeit = 0;
+
+		if ( !ca_list ) {
+			ca_list = sk_X509_NAME_new_null();
+			freeit = 1;
+		}
+		if ( !SSL_add_dir_cert_subjects_to_stack( ca_list, dir ) &&
+			freeit ) {
+			sk_X509_NAME_free( ca_list );
+			ca_list = NULL;
+		}
+	}
+#endif
+	return ca_list;
+}
+
+/*
+ * Initialize TLS subsystem. Should be called only once.
+ */
+static int
+tlso_init( void )
+{
+	struct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   
+#ifdef HAVE_EBCDIC
+	{
+		char *file = LDAP_STRDUP( lo->ldo_tls_randfile );
+		if ( file ) __atoe( file );
+		(void) tlso_seed_PRNG( file );
+		LDAP_FREE( file );
+	}
+#else
+	(void) tlso_seed_PRNG( lo->ldo_tls_randfile );
+#endif
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+	SSL_load_error_strings();
+	SSL_library_init();
+	OpenSSL_add_all_digests();
+#else
+	OPENSSL_init_ssl(0, NULL);
+#endif
+
+	/* FIXME: mod_ssl does this */
+	X509V3_add_standard_extensions();
+
+	return 0;
+}
+
+/*
+ * Tear down the TLS subsystem. Should only be called once.
+ */
+static void
+tlso_destroy( void )
+{
+	struct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+	EVP_cleanup();
+#if OPENSSL_VERSION_NUMBER < 0x10000000
+	ERR_remove_state(0);
+#else
+	ERR_remove_thread_state(NULL);
+#endif
+	ERR_free_strings();
+#endif
+
+	if ( lo->ldo_tls_randfile ) {
+		LDAP_FREE( lo->ldo_tls_randfile );
+		lo->ldo_tls_randfile = NULL;
+	}
+}
+
+static tls_ctx *
+tlso_ctx_new( struct ldapoptions *lo )
+{
+	return (tls_ctx *) SSL_CTX_new( SSLv23_method() );
+}
+
+static void
+tlso_ctx_ref( tls_ctx *ctx )
+{
+	tlso_ctx *c = (tlso_ctx *)ctx;
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+#define	SSL_CTX_up_ref(ctx)	CRYPTO_add( &(ctx->references), 1, CRYPTO_LOCK_SSL_CTX )
+#endif
+	SSL_CTX_up_ref( c );
+}
+
+static void
+tlso_ctx_free ( tls_ctx *ctx )
+{
+	tlso_ctx *c = (tlso_ctx *)ctx;
+	SSL_CTX_free( c );
+}
+
+/*
+ * initialize a new TLS context
+ */
+static int
+tlso_ctx_init( struct ldapoptions *lo, struct ldaptls *lt, int is_server )
+{
+	tlso_ctx *ctx = (tlso_ctx *)lo->ldo_tls_ctx;
+	int i;
+
+	if ( is_server ) {
+		SSL_CTX_set_session_id_context( ctx,
+			(const unsigned char *) "OpenLDAP", sizeof("OpenLDAP")-1 );
+	}
+
+#ifdef SSL_OP_NO_TLSv1
+#ifdef SSL_OP_NO_TLSv1_1
+#ifdef SSL_OP_NO_TLSv1_2
+	if ( lo->ldo_tls_protocol_min > LDAP_OPT_X_TLS_PROTOCOL_TLS1_2)
+		SSL_CTX_set_options( ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 |
+			SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1 |
+			SSL_OP_NO_TLSv1_2 );
+	else
+#endif
+	if ( lo->ldo_tls_protocol_min > LDAP_OPT_X_TLS_PROTOCOL_TLS1_1)
+		SSL_CTX_set_options( ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 |
+			SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1 );
+	else
+#endif
+	if ( lo->ldo_tls_protocol_min > LDAP_OPT_X_TLS_PROTOCOL_TLS1_0)
+		SSL_CTX_set_options( ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 |
+			SSL_OP_NO_TLSv1);
+	else
+#endif
+	if ( lo->ldo_tls_protocol_min > LDAP_OPT_X_TLS_PROTOCOL_SSL3 )
+		SSL_CTX_set_options( ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 );
+	else if ( lo->ldo_tls_protocol_min > LDAP_OPT_X_TLS_PROTOCOL_SSL2 )
+		SSL_CTX_set_options( ctx, SSL_OP_NO_SSLv2 );
+
+	if ( lo->ldo_tls_ciphersuite &&
+		!SSL_CTX_set_cipher_list( ctx, lt->lt_ciphersuite ) )
+	{
+		Debug( LDAP_DEBUG_ANY,
+			   "TLS: could not set cipher list %s.\n",
+			   lo->ldo_tls_ciphersuite, 0, 0 );
+		tlso_report_error();
+		return -1;
+	}
+
+	if ( lo->ldo_tls_cacertfile == NULL && lo->ldo_tls_cacertdir == NULL ) {
+		if ( !SSL_CTX_set_default_verify_paths( ctx ) ) {
+			Debug( LDAP_DEBUG_ANY, "TLS: "
+				"could not use default certificate paths", 0, 0, 0 );
+			tlso_report_error();
+			return -1;
+		}
+	} else {
+		if ( !SSL_CTX_load_verify_locations( ctx,
+				lt->lt_cacertfile, lt->lt_cacertdir ) )
+		{
+			Debug( LDAP_DEBUG_ANY, "TLS: "
+				"could not load verify locations (file:`%s',dir:`%s').\n",
+				lo->ldo_tls_cacertfile ? lo->ldo_tls_cacertfile : "",
+				lo->ldo_tls_cacertdir ? lo->ldo_tls_cacertdir : "",
+				0 );
+			tlso_report_error();
+			return -1;
+		}
+
+		if ( is_server ) {
+			STACK_OF(X509_NAME) *calist;
+			/* List of CA names to send to a client */
+			calist = tlso_ca_list( lt->lt_cacertfile, lt->lt_cacertdir );
+			if ( !calist ) {
+				Debug( LDAP_DEBUG_ANY, "TLS: "
+					"could not load client CA list (file:`%s',dir:`%s').\n",
+					lo->ldo_tls_cacertfile ? lo->ldo_tls_cacertfile : "",
+					lo->ldo_tls_cacertdir ? lo->ldo_tls_cacertdir : "",
+					0 );
+				tlso_report_error();
+				return -1;
+			}
+
+			SSL_CTX_set_client_CA_list( ctx, calist );
+		}
+	}
+
+	if ( lo->ldo_tls_certfile &&
+		!SSL_CTX_use_certificate_file( ctx,
+			lt->lt_certfile, SSL_FILETYPE_PEM ) )
+	{
+		Debug( LDAP_DEBUG_ANY,
+			"TLS: could not use certificate `%s'.\n",
+			lo->ldo_tls_certfile,0,0);
+		tlso_report_error();
+		return -1;
+	}
+
+	/* Key validity is checked automatically if cert has already been set */
+	if ( lo->ldo_tls_keyfile &&
+		!SSL_CTX_use_PrivateKey_file( ctx,
+			lt->lt_keyfile, SSL_FILETYPE_PEM ) )
+	{
+		Debug( LDAP_DEBUG_ANY,
+			"TLS: could not use key file `%s'.\n",
+			lo->ldo_tls_keyfile,0,0);
+		tlso_report_error();
+		return -1;
+	}
+
+	if ( lo->ldo_tls_dhfile ) {
+		DH *dh = NULL;
+		BIO *bio;
+		SSL_CTX_set_options( ctx, SSL_OP_SINGLE_DH_USE );
+
+		if (( bio=BIO_new_file( lt->lt_dhfile,"r" )) == NULL ) {
+			Debug( LDAP_DEBUG_ANY,
+				"TLS: could not use DH parameters file `%s'.\n",
+				lo->ldo_tls_dhfile,0,0);
+			tlso_report_error();
+			return -1;
+		}
+		if (!( dh=PEM_read_bio_DHparams( bio, NULL, NULL, NULL ))) {
+			Debug( LDAP_DEBUG_ANY,
+				"TLS: could not read DH parameters file `%s'.\n",
+				lo->ldo_tls_dhfile,0,0);
+			tlso_report_error();
+			BIO_free( bio );
+			return -1;
+		}
+		BIO_free( bio );
+		SSL_CTX_set_tmp_dh( ctx, dh );
+	}
+
+	if ( tlso_opt_trace ) {
+		SSL_CTX_set_info_callback( ctx, tlso_info_cb );
+	}
+
+	i = SSL_VERIFY_NONE;
+	if ( lo->ldo_tls_require_cert ) {
+		i = SSL_VERIFY_PEER;
+		if ( lo->ldo_tls_require_cert == LDAP_OPT_X_TLS_DEMAND ||
+			 lo->ldo_tls_require_cert == LDAP_OPT_X_TLS_HARD ) {
+			i |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
+		}
+	}
+
+	SSL_CTX_set_verify( ctx, i,
+		lo->ldo_tls_require_cert == LDAP_OPT_X_TLS_ALLOW ?
+		tlso_verify_ok : tlso_verify_cb );
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+	SSL_CTX_set_tmp_rsa_callback( ctx, tlso_tmp_rsa_cb );
+#endif
+#ifdef HAVE_OPENSSL_CRL
+	if ( lo->ldo_tls_crlcheck ) {
+		X509_STORE *x509_s = SSL_CTX_get_cert_store( ctx );
+		if ( lo->ldo_tls_crlcheck == LDAP_OPT_X_TLS_CRL_PEER ) {
+			X509_STORE_set_flags( x509_s, X509_V_FLAG_CRL_CHECK );
+		} else if ( lo->ldo_tls_crlcheck == LDAP_OPT_X_TLS_CRL_ALL ) {
+			X509_STORE_set_flags( x509_s, 
+					X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL  );
+		}
+	}
+#endif
+	return 0;
+}
+
+static tls_session *
+tlso_session_new( tls_ctx *ctx, int is_server )
+{
+	tlso_ctx *c = (tlso_ctx *)ctx;
+	return (tls_session *)SSL_new( c );
+}
+
+static int
+tlso_session_connect( LDAP *ld, tls_session *sess )
+{
+	tlso_session *s = (tlso_session *)sess;
+
+	/* Caller expects 0 = success, OpenSSL returns 1 = success */
+	return SSL_connect( s ) - 1;
+}
+
+static int
+tlso_session_accept( tls_session *sess )
+{
+	tlso_session *s = (tlso_session *)sess;
+
+	/* Caller expects 0 = success, OpenSSL returns 1 = success */
+	return SSL_accept( s ) - 1;
+}
+
+static int
+tlso_session_upflags( Sockbuf *sb, tls_session *sess, int rc )
+{
+	tlso_session *s = (tlso_session *)sess;
+
+	/* 1 was subtracted above, offset it back now */
+	rc = SSL_get_error(s, rc+1);
+	if (rc == SSL_ERROR_WANT_READ) {
+		sb->sb_trans_needs_read  = 1;
+		return 1;
+
+	} else if (rc == SSL_ERROR_WANT_WRITE) {
+		sb->sb_trans_needs_write = 1;
+		return 1;
+
+	} else if (rc == SSL_ERROR_WANT_CONNECT) {
+		return 1;
+	}
+	return 0;
+}
+
+static char *
+tlso_session_errmsg( tls_session *sess, int rc, char *buf, size_t len )
+{
+	char err[256] = "";
+	const char *certerr=NULL;
+	tlso_session *s = (tlso_session *)sess;
+
+	rc = ERR_peek_error();
+	if ( rc ) {
+		ERR_error_string_n( rc, err, sizeof(err) );
+		if ( ( ERR_GET_LIB(rc) == ERR_LIB_SSL ) && 
+				( ERR_GET_REASON(rc) == SSL_R_CERTIFICATE_VERIFY_FAILED ) ) {
+			int certrc = SSL_get_verify_result(s);
+			certerr = (char *)X509_verify_cert_error_string(certrc);
+		}
+		snprintf(buf, len, "%s%s%s%s", err, certerr ? " (" :"", 
+				certerr ? certerr : "", certerr ?  ")" : "" );
+		return buf;
+	}
+	return NULL;
+}
+
+static int
+tlso_session_my_dn( tls_session *sess, struct berval *der_dn )
+{
+	tlso_session *s = (tlso_session *)sess;
+	X509 *x;
+	X509_NAME *xn;
+
+	x = SSL_get_certificate( s );
+
+	if (!x) return LDAP_INVALID_CREDENTIALS;
+	
+	xn = X509_get_subject_name(x);
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+	der_dn->bv_len = i2d_X509_NAME( xn, NULL );
+	der_dn->bv_val = xn->bytes->data;
+#else
+	{
+		size_t len = 0;
+		der_dn->bv_val = NULL;
+		X509_NAME_get0_der( xn, (const unsigned char **)&der_dn->bv_val, &len );
+		der_dn->bv_len = len;
+	}
+#endif
+	/* Don't X509_free, the session is still using it */
+	return 0;
+}
+
+static X509 *
+tlso_get_cert( SSL *s )
+{
+	/* If peer cert was bad, treat as if no cert was given */
+	if (SSL_get_verify_result(s)) {
+		return NULL;
+	}
+	return SSL_get_peer_certificate(s);
+}
+
+static int
+tlso_session_peer_dn( tls_session *sess, struct berval *der_dn )
+{
+	tlso_session *s = (tlso_session *)sess;
+	X509 *x = tlso_get_cert( s );
+	X509_NAME *xn;
+
+	if ( !x )
+		return LDAP_INVALID_CREDENTIALS;
+
+	xn = X509_get_subject_name(x);
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+	der_dn->bv_len = i2d_X509_NAME( xn, NULL );
+	der_dn->bv_val = xn->bytes->data;
+#else
+	{
+		size_t len = 0;
+		der_dn->bv_val = NULL;
+		X509_NAME_get0_der( xn, (const unsigned char **)&der_dn->bv_val, &len );
+		der_dn->bv_len = len;
+	}
+#endif
+	X509_free(x);
+	return 0;
+}
+
+/* what kind of hostname were we given? */
+#define	IS_DNS	0
+#define	IS_IP4	1
+#define	IS_IP6	2
+
+static int
+tlso_session_chkhost( LDAP *ld, tls_session *sess, const char *name_in )
+{
+	tlso_session *s = (tlso_session *)sess;
+	int i, ret = LDAP_LOCAL_ERROR;
+	X509 *x;
+	const char *name;
+	char *ptr;
+	int ntype = IS_DNS, nlen;
+#ifdef LDAP_PF_INET6
+	struct in6_addr addr;
+#else
+	struct in_addr addr;
+#endif
+
+	if( ldap_int_hostname &&
+		( !name_in || !strcasecmp( name_in, "localhost" ) ) )
+	{
+		name = ldap_int_hostname;
+	} else {
+		name = name_in;
+	}
+	nlen = strlen(name);
+
+	x = tlso_get_cert(s);
+	if (!x) {
+		Debug( LDAP_DEBUG_ANY,
+			"TLS: unable to get peer certificate.\n",
+			0, 0, 0 );
+		/* If this was a fatal condition, things would have
+		 * aborted long before now.
+		 */
+		return LDAP_SUCCESS;
+	}
+
+#ifdef LDAP_PF_INET6
+	if (inet_pton(AF_INET6, name, &addr)) {
+		ntype = IS_IP6;
+	} else 
+#endif
+	if ((ptr = strrchr(name, '.')) && isdigit((unsigned char)ptr[1])) {
+		if (inet_aton(name, (struct in_addr *)&addr)) ntype = IS_IP4;
+	}
+	
+	i = X509_get_ext_by_NID(x, NID_subject_alt_name, -1);
+	if (i >= 0) {
+		X509_EXTENSION *ex;
+		STACK_OF(GENERAL_NAME) *alt;
+
+		ex = X509_get_ext(x, i);
+		alt = X509V3_EXT_d2i(ex);
+		if (alt) {
+			int n, len2 = 0;
+			char *domain = NULL;
+			GENERAL_NAME *gn;
+
+			if (ntype == IS_DNS) {
+				domain = strchr(name, '.');
+				if (domain) {
+					len2 = nlen - (domain-name);
+				}
+			}
+			n = sk_GENERAL_NAME_num(alt);
+			for (i=0; i<n; i++) {
+				char *sn;
+				int sl;
+				gn = sk_GENERAL_NAME_value(alt, i);
+				if (gn->type == GEN_DNS) {
+					if (ntype != IS_DNS) continue;
+
+					sn = (char *) ASN1_STRING_data(gn->d.ia5);
+					sl = ASN1_STRING_length(gn->d.ia5);
+
+					/* ignore empty */
+					if (sl == 0) continue;
+
+					/* Is this an exact match? */
+					if ((nlen == sl) && !strncasecmp(name, sn, nlen)) {
+						break;
+					}
+
+					/* Is this a wildcard match? */
+					if (domain && (sn[0] == '*') && (sn[1] == '.') &&
+						(len2 == sl-1) && !strncasecmp(domain, &sn[1], len2))
+					{
+						break;
+					}
+
+				} else if (gn->type == GEN_IPADD) {
+					if (ntype == IS_DNS) continue;
+
+					sn = (char *) ASN1_STRING_data(gn->d.ia5);
+					sl = ASN1_STRING_length(gn->d.ia5);
+
+#ifdef LDAP_PF_INET6
+					if (ntype == IS_IP6 && sl != sizeof(struct in6_addr)) {
+						continue;
+					} else
+#endif
+					if (ntype == IS_IP4 && sl != sizeof(struct in_addr)) {
+						continue;
+					}
+					if (!memcmp(sn, &addr, sl)) {
+						break;
+					}
+				}
+			}
+
+			GENERAL_NAMES_free(alt);
+			if (i < n) {	/* Found a match */
+				ret = LDAP_SUCCESS;
+			}
+		}
+	}
+
+	if (ret != LDAP_SUCCESS) {
+		X509_NAME *xn;
+		X509_NAME_ENTRY *ne;
+		ASN1_OBJECT *obj;
+		ASN1_STRING *cn = NULL;
+		int navas;
+
+		/* find the last CN */
+		obj = OBJ_nid2obj( NID_commonName );
+		if ( !obj ) goto no_cn;	/* should never happen */
+
+		xn = X509_get_subject_name(x);
+		navas = X509_NAME_entry_count( xn );
+		for ( i=navas-1; i>=0; i-- ) {
+			ne = X509_NAME_get_entry( xn, i );
+			if ( !OBJ_cmp( X509_NAME_ENTRY_get_object(ne), obj )) {
+				cn = X509_NAME_ENTRY_get_data( ne );
+				break;
+			}
+		}
+
+		if( !cn )
+		{
+no_cn:
+			Debug( LDAP_DEBUG_ANY,
+				"TLS: unable to get common name from peer certificate.\n",
+				0, 0, 0 );
+			ret = LDAP_CONNECT_ERROR;
+			if ( ld->ld_error ) {
+				LDAP_FREE( ld->ld_error );
+			}
+			ld->ld_error = LDAP_STRDUP(
+				_("TLS: unable to get CN from peer certificate"));
+
+		} else if ( cn->length == nlen &&
+			strncasecmp( name, (char *) cn->data, nlen ) == 0 ) {
+			ret = LDAP_SUCCESS;
+
+		} else if (( cn->data[0] == '*' ) && ( cn->data[1] == '.' )) {
+			char *domain = strchr(name, '.');
+			if( domain ) {
+				int dlen;
+
+				dlen = nlen - (domain-name);
+
+				/* Is this a wildcard match? */
+				if ((dlen == cn->length-1) &&
+					!strncasecmp(domain, (char *) &cn->data[1], dlen)) {
+					ret = LDAP_SUCCESS;
+				}
+			}
+		}
+
+		if( ret == LDAP_LOCAL_ERROR ) {
+			Debug( LDAP_DEBUG_ANY, "TLS: hostname (%s) does not match "
+				"common name in certificate (%.*s).\n", 
+				name, cn->length, cn->data );
+			ret = LDAP_CONNECT_ERROR;
+			if ( ld->ld_error ) {
+				LDAP_FREE( ld->ld_error );
+			}
+			ld->ld_error = LDAP_STRDUP(
+				_("TLS: hostname does not match CN in peer certificate"));
+		}
+	}
+	X509_free(x);
+	return ret;
+}
+
+static int
+tlso_session_strength( tls_session *sess )
+{
+	tlso_session *s = (tlso_session *)sess;
+
+	return SSL_CIPHER_get_bits(SSL_get_current_cipher(s), NULL);
+}
+
+/*
+ * TLS support for LBER Sockbufs
+ */
+
+struct tls_data {
+	tlso_session		*session;
+	Sockbuf_IO_Desc		*sbiod;
+};
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+#define BIO_set_init(b, x)	b->init = x
+#define BIO_set_data(b, x)	b->ptr = x
+#define BIO_clear_flags(b, x)	b->flags &= ~(x)
+#define BIO_get_data(b)	b->ptr
+#endif
+static int
+tlso_bio_create( BIO *b ) {
+	BIO_set_init( b, 1 );
+	BIO_set_data( b, NULL );
+	BIO_clear_flags( b, ~0 );
+	return 1;
+}
+
+static int
+tlso_bio_destroy( BIO *b )
+{
+	if ( b == NULL ) return 0;
+
+	BIO_set_data( b, NULL );		/* sb_tls_remove() will free it */
+	BIO_set_init( b, 0 );
+	BIO_clear_flags( b, ~0 );
+	return 1;
+}
+
+static int
+tlso_bio_read( BIO *b, char *buf, int len )
+{
+	struct tls_data		*p;
+	int			ret;
+		
+	if ( buf == NULL || len <= 0 ) return 0;
+
+	p = (struct tls_data *)BIO_get_data(b);
+
+	if ( p == NULL || p->sbiod == NULL ) {
+		return 0;
+	}
+
+	ret = LBER_SBIOD_READ_NEXT( p->sbiod, buf, len );
+
+	BIO_clear_retry_flags( b );
+	if ( ret < 0 ) {
+		int err = sock_errno();
+		if ( err == EAGAIN || err == EWOULDBLOCK ) {
+			BIO_set_retry_read( b );
+		}
+	}
+
+	return ret;
+}
+
+static int
+tlso_bio_write( BIO *b, const char *buf, int len )
+{
+	struct tls_data		*p;
+	int			ret;
+	
+	if ( buf == NULL || len <= 0 ) return 0;
+	
+	p = (struct tls_data *)BIO_get_data(b);
+
+	if ( p == NULL || p->sbiod == NULL ) {
+		return 0;
+	}
+
+	ret = LBER_SBIOD_WRITE_NEXT( p->sbiod, (char *)buf, len );
+
+	BIO_clear_retry_flags( b );
+	if ( ret < 0 ) {
+		int err = sock_errno();
+		if ( err == EAGAIN || err == EWOULDBLOCK ) {
+			BIO_set_retry_write( b );
+		}
+	}
+
+	return ret;
+}
+
+static long
+tlso_bio_ctrl( BIO *b, int cmd, long num, void *ptr )
+{
+	if ( cmd == BIO_CTRL_FLUSH ) {
+		/* The OpenSSL library needs this */
+		return 1;
+	}
+	return 0;
+}
+
+static int
+tlso_bio_gets( BIO *b, char *buf, int len )
+{
+	return -1;
+}
+
+static int
+tlso_bio_puts( BIO *b, const char *str )
+{
+	return tlso_bio_write( b, str, strlen( str ) );
+}
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000
+struct bio_method_st {
+    int type;
+    const char *name;
+    int (*bwrite) (BIO *, const char *, int);
+    int (*bread) (BIO *, char *, int);
+    int (*bputs) (BIO *, const char *);
+    int (*bgets) (BIO *, char *, int);
+    long (*ctrl) (BIO *, int, long, void *);
+    int (*create) (BIO *);
+    int (*destroy) (BIO *);
+    long (*callback_ctrl) (BIO *, int, bio_info_cb *);
+};
+#endif
+
+static BIO_METHOD tlso_bio_method =
+{
+	( 100 | 0x400 ),		/* it's a source/sink BIO */
+	"sockbuf glue",
+	tlso_bio_write,
+	tlso_bio_read,
+	tlso_bio_puts,
+	tlso_bio_gets,
+	tlso_bio_ctrl,
+	tlso_bio_create,
+	tlso_bio_destroy
+};
+
+static int
+tlso_sb_setup( Sockbuf_IO_Desc *sbiod, void *arg )
+{
+	struct tls_data		*p;
+	BIO			*bio;
+
+	assert( sbiod != NULL );
+
+	p = LBER_MALLOC( sizeof( *p ) );
+	if ( p == NULL ) {
+		return -1;
+	}
+	
+	p->session = arg;
+	p->sbiod = sbiod;
+	bio = BIO_new( &tlso_bio_method );
+	BIO_set_data( bio, p );
+	SSL_set_bio( p->session, bio, bio );
+	sbiod->sbiod_pvt = p;
+	return 0;
+}
+
+static int
+tlso_sb_remove( Sockbuf_IO_Desc *sbiod )
+{
+	struct tls_data		*p;
+	
+	assert( sbiod != NULL );
+	assert( sbiod->sbiod_pvt != NULL );
+
+	p = (struct tls_data *)sbiod->sbiod_pvt;
+	SSL_free( p->session );
+	LBER_FREE( sbiod->sbiod_pvt );
+	sbiod->sbiod_pvt = NULL;
+	return 0;
+}
+
+static int
+tlso_sb_close( Sockbuf_IO_Desc *sbiod )
+{
+	struct tls_data		*p;
+	
+	assert( sbiod != NULL );
+	assert( sbiod->sbiod_pvt != NULL );
+
+	p = (struct tls_data *)sbiod->sbiod_pvt;
+	SSL_shutdown( p->session );
+	return 0;
+}
+
+static int
+tlso_sb_ctrl( Sockbuf_IO_Desc *sbiod, int opt, void *arg )
+{
+	struct tls_data		*p;
+	
+	assert( sbiod != NULL );
+	assert( sbiod->sbiod_pvt != NULL );
+
+	p = (struct tls_data *)sbiod->sbiod_pvt;
+	
+	if ( opt == LBER_SB_OPT_GET_SSL ) {
+		*((tlso_session **)arg) = p->session;
+		return 1;
+
+	} else if ( opt == LBER_SB_OPT_DATA_READY ) {
+		if( SSL_pending( p->session ) > 0 ) {
+			return 1;
+		}
+	}
+	
+	return LBER_SBIOD_CTRL_NEXT( sbiod, opt, arg );
+}
+
+static ber_slen_t
+tlso_sb_read( Sockbuf_IO_Desc *sbiod, void *buf, ber_len_t len)
+{
+	struct tls_data		*p;
+	ber_slen_t		ret;
+	int			err;
+
+	assert( sbiod != NULL );
+	assert( SOCKBUF_VALID( sbiod->sbiod_sb ) );
+
+	p = (struct tls_data *)sbiod->sbiod_pvt;
+
+	ret = SSL_read( p->session, (char *)buf, len );
+#ifdef HAVE_WINSOCK
+	errno = WSAGetLastError();
+#endif
+	err = SSL_get_error( p->session, ret );
+	if (err == SSL_ERROR_WANT_READ ) {
+		sbiod->sbiod_sb->sb_trans_needs_read = 1;
+		sock_errset(EWOULDBLOCK);
+	}
+	else
+		sbiod->sbiod_sb->sb_trans_needs_read = 0;
+	return ret;
+}
+
+static ber_slen_t
+tlso_sb_write( Sockbuf_IO_Desc *sbiod, void *buf, ber_len_t len)
+{
+	struct tls_data		*p;
+	ber_slen_t		ret;
+	int			err;
+
+	assert( sbiod != NULL );
+	assert( SOCKBUF_VALID( sbiod->sbiod_sb ) );
+
+	p = (struct tls_data *)sbiod->sbiod_pvt;
+
+	ret = SSL_write( p->session, (char *)buf, len );
+#ifdef HAVE_WINSOCK
+	errno = WSAGetLastError();
+#endif
+	err = SSL_get_error( p->session, ret );
+	if (err == SSL_ERROR_WANT_WRITE ) {
+		sbiod->sbiod_sb->sb_trans_needs_write = 1;
+		sock_errset(EWOULDBLOCK);
+
+	} else {
+		sbiod->sbiod_sb->sb_trans_needs_write = 0;
+	}
+	return ret;
+}
+
+static Sockbuf_IO tlso_sbio =
+{
+	tlso_sb_setup,		/* sbi_setup */
+	tlso_sb_remove,		/* sbi_remove */
+	tlso_sb_ctrl,		/* sbi_ctrl */
+	tlso_sb_read,		/* sbi_read */
+	tlso_sb_write,		/* sbi_write */
+	tlso_sb_close		/* sbi_close */
+};
+
+/* Derived from openssl/apps/s_cb.c */
+static void
+tlso_info_cb( const SSL *ssl, int where, int ret )
+{
+	int w;
+	char *op;
+	char *state = (char *) SSL_state_string_long( (SSL *)ssl );
+
+	w = where & ~SSL_ST_MASK;
+	if ( w & SSL_ST_CONNECT ) {
+		op = "SSL_connect";
+	} else if ( w & SSL_ST_ACCEPT ) {
+		op = "SSL_accept";
+	} else {
+		op = "undefined";
+	}
+
+#ifdef HAVE_EBCDIC
+	if ( state ) {
+		state = LDAP_STRDUP( state );
+		__etoa( state );
+	}
+#endif
+	if ( where & SSL_CB_LOOP ) {
+		Debug( LDAP_DEBUG_TRACE,
+			   "TLS trace: %s:%s\n",
+			   op, state, 0 );
+
+	} else if ( where & SSL_CB_ALERT ) {
+		char *atype = (char *) SSL_alert_type_string_long( ret );
+		char *adesc = (char *) SSL_alert_desc_string_long( ret );
+		op = ( where & SSL_CB_READ ) ? "read" : "write";
+#ifdef HAVE_EBCDIC
+		if ( atype ) {
+			atype = LDAP_STRDUP( atype );
+			__etoa( atype );
+		}
+		if ( adesc ) {
+			adesc = LDAP_STRDUP( adesc );
+			__etoa( adesc );
+		}
+#endif
+		Debug( LDAP_DEBUG_TRACE,
+			   "TLS trace: SSL3 alert %s:%s:%s\n",
+			   op, atype, adesc );
+#ifdef HAVE_EBCDIC
+		if ( atype ) LDAP_FREE( atype );
+		if ( adesc ) LDAP_FREE( adesc );
+#endif
+	} else if ( where & SSL_CB_EXIT ) {
+		if ( ret == 0 ) {
+			Debug( LDAP_DEBUG_TRACE,
+				   "TLS trace: %s:failed in %s\n",
+				   op, state, 0 );
+		} else if ( ret < 0 ) {
+			Debug( LDAP_DEBUG_TRACE,
+				   "TLS trace: %s:error in %s\n",
+				   op, state, 0 );
+		}
+	}
+#ifdef HAVE_EBCDIC
+	if ( state ) LDAP_FREE( state );
+#endif
+}
+
+static int
+tlso_verify_cb( int ok, X509_STORE_CTX *ctx )
+{
+	X509 *cert;
+	int errnum;
+	int errdepth;
+	X509_NAME *subject;
+	X509_NAME *issuer;
+	char *sname;
+	char *iname;
+	char *certerr = NULL;
+
+	cert = X509_STORE_CTX_get_current_cert( ctx );
+	errnum = X509_STORE_CTX_get_error( ctx );
+	errdepth = X509_STORE_CTX_get_error_depth( ctx );
+
+	/*
+	 * X509_get_*_name return pointers to the internal copies of
+	 * those things requested.  So do not free them.
+	 */
+	subject = X509_get_subject_name( cert );
+	issuer = X509_get_issuer_name( cert );
+	/* X509_NAME_oneline, if passed a NULL buf, allocate memomry */
+	sname = X509_NAME_oneline( subject, NULL, 0 );
+	iname = X509_NAME_oneline( issuer, NULL, 0 );
+	if ( !ok ) certerr = (char *)X509_verify_cert_error_string( errnum );
+#ifdef HAVE_EBCDIC
+	if ( sname ) __etoa( sname );
+	if ( iname ) __etoa( iname );
+	if ( certerr ) {
+		certerr = LDAP_STRDUP( certerr );
+		__etoa( certerr );
+	}
+#endif
+	Debug( LDAP_DEBUG_TRACE,
+		   "TLS certificate verification: depth: %d, err: %d, subject: %s,",
+		   errdepth, errnum,
+		   sname ? sname : "-unknown-" );
+	Debug( LDAP_DEBUG_TRACE, " issuer: %s\n", iname ? iname : "-unknown-", 0, 0 );
+	if ( !ok ) {
+		Debug( LDAP_DEBUG_ANY,
+			"TLS certificate verification: Error, %s\n",
+			certerr, 0, 0 );
+	}
+	if ( sname )
+		OPENSSL_free ( sname );
+	if ( iname )
+		OPENSSL_free ( iname );
+#ifdef HAVE_EBCDIC
+	if ( certerr ) LDAP_FREE( certerr );
+#endif
+	return ok;
+}
+
+static int
+tlso_verify_ok( int ok, X509_STORE_CTX *ctx )
+{
+	(void) tlso_verify_cb( ok, ctx );
+	return 1;
+}
+
+/* Inspired by ERR_print_errors in OpenSSL */
+static void
+tlso_report_error( void )
+{
+	unsigned long l;
+	char buf[200];
+	const char *file;
+	int line;
+
+	while ( ( l = ERR_get_error_line( &file, &line ) ) != 0 ) {
+		ERR_error_string_n( l, buf, sizeof( buf ) );
+#ifdef HAVE_EBCDIC
+		if ( file ) {
+			file = LDAP_STRDUP( file );
+			__etoa( (char *)file );
+		}
+		__etoa( buf );
+#endif
+		Debug( LDAP_DEBUG_ANY, "TLS: %s %s:%d\n",
+			buf, file, line );
+#ifdef HAVE_EBCDIC
+		if ( file ) LDAP_FREE( (void *)file );
+#endif
+	}
+}
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000
+static RSA *
+tlso_tmp_rsa_cb( SSL *ssl, int is_export, int key_length )
+{
+	RSA *tmp_rsa;
+	/* FIXME:  Pregenerate the key on startup */
+	/* FIXME:  Who frees the key? */
+#if OPENSSL_VERSION_NUMBER >= 0x00908000
+	BIGNUM *bn = BN_new();
+	tmp_rsa = NULL;
+	if ( bn ) {
+		if ( BN_set_word( bn, RSA_F4 )) {
+			tmp_rsa = RSA_new();
+			if ( tmp_rsa && !RSA_generate_key_ex( tmp_rsa, key_length, bn, NULL )) {
+				RSA_free( tmp_rsa );
+				tmp_rsa = NULL;
+			}
+		}
+		BN_free( bn );
+	}
+#else
+	tmp_rsa = RSA_generate_key( key_length, RSA_F4, NULL, NULL );
+#endif
+
+	if ( !tmp_rsa ) {
+		Debug( LDAP_DEBUG_ANY,
+			"TLS: Failed to generate temporary %d-bit %s RSA key\n",
+			key_length, is_export ? "export" : "domestic", 0 );
+	}
+	return tmp_rsa;
+}
+#endif /* OPENSSL_VERSION_NUMBER < 1.1 */
+
+static int
+tlso_seed_PRNG( const char *randfile )
+{
+#ifndef URANDOM_DEVICE
+	/* no /dev/urandom (or equiv) */
+	long total=0;
+	char buffer[MAXPATHLEN];
+
+	if (randfile == NULL) {
+		/* The seed file is $RANDFILE if defined, otherwise $HOME/.rnd.
+		 * If $HOME is not set or buffer too small to hold the pathname,
+		 * an error occurs.	- From RAND_file_name() man page.
+		 * The fact is that when $HOME is NULL, .rnd is used.
+		 */
+		randfile = RAND_file_name( buffer, sizeof( buffer ) );
+
+	} else if (RAND_egd(randfile) > 0) {
+		/* EGD socket */
+		return 0;
+	}
+
+	if (randfile == NULL) {
+		Debug( LDAP_DEBUG_ANY,
+			"TLS: Use configuration file or $RANDFILE to define seed PRNG\n",
+			0, 0, 0);
+		return -1;
+	}
+
+	total = RAND_load_file(randfile, -1);
+
+	if (RAND_status() == 0) {
+		Debug( LDAP_DEBUG_ANY,
+			"TLS: PRNG not been seeded with enough data\n",
+			0, 0, 0);
+		return -1;
+	}
+
+	/* assume if there was enough bits to seed that it's okay
+	 * to write derived bits to the file
+	 */
+	RAND_write_file(randfile);
+
+#endif
+
+	return 0;
+}
+
+
+tls_impl ldap_int_tls_impl = {
+	"OpenSSL",
+
+	tlso_init,
+	tlso_destroy,
+
+	tlso_ctx_new,
+	tlso_ctx_ref,
+	tlso_ctx_free,
+	tlso_ctx_init,
+
+	tlso_session_new,
+	tlso_session_connect,
+	tlso_session_accept,
+	tlso_session_upflags,
+	tlso_session_errmsg,
+	tlso_session_my_dn,
+	tlso_session_peer_dn,
+	tlso_session_chkhost,
+	tlso_session_strength,
+
+	&tlso_sbio,
+
+#ifdef LDAP_R_COMPILE
+	tlso_thr_init,
+#else
+	NULL,
+#endif
+
+	0
+};
+
+#endif /* HAVE_OPENSSL */
diff --git a/src/libraries/libldap/tls_o.c.rej b/src/libraries/libldap/tls_o.c.rej
new file mode 100644
index 0000000..0fc17ec
--- /dev/null
+++ b/src/libraries/libldap/tls_o.c.rej
@@ -0,0 +1,16 @@
+--- libraries/libldap/tls_o.c	2012-10-10 14:18:49.000000000 +0200
++++ libraries/libldap/tls_o.c	2013-01-24 23:36:15.269546400 +0100
+@@ -180,11 +182,12 @@
+ 	EVP_cleanup();
+ 	ERR_remove_state(0);
+ 	ERR_free_strings();
+-
++#ifdef HAVE_TLS
+ 	if ( lo->ldo_tls_randfile ) {
+ 		LDAP_FREE( lo->ldo_tls_randfile );
+ 		lo->ldo_tls_randfile = NULL;
+ 	}
++ #endif /* HAVE_TLS */
+ }
+ 
+ static tls_ctx *
diff --git a/src/libraries/libldap_r/CMakeLists.txt b/src/libraries/libldap_r/CMakeLists.txt
new file mode 100644
index 0000000..69fe394
--- /dev/null
+++ b/src/libraries/libldap_r/CMakeLists.txt
@@ -0,0 +1,95 @@
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../libldap)
+set(ldap_r_SRCS
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/bind.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/open.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/result.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/error.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/compare.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/search.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/controls.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/messages.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/references.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/extended.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/cyrus.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/modify.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/add.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/modrdn.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/delete.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/abandon.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/sasl.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/gssapi.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/sbind.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/unbind.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/cancel.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/filter.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/free.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/sort.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/passwd.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/whoami.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/getdn.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/getentry.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/getattr.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/getvalues.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/addentry.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/request.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/os-ip.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/url.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/pagectrl.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/sortctrl.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/vlvctrl.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/init.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/options.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/print.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/string.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/util-int.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/schema.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/charray.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/os-local.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/dnssrv.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/utf-8.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/utf-8-conv.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/tls2.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/tls_o.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/tls_g.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/tls_m.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/turn.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/ppolicy.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/dds.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/txn.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/ldap_sync.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/stctrl.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/assertion.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/deref.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/ldif.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../libldap/fetch.c
+)
+
+set(ldap_r_add_SRCS
+    threads.c
+    rdwr.c
+    rmutex.c
+    tpool.c
+    rq.c
+    thr_posix.c
+    thr_cthreads.c
+    thr_thr.c
+    thr_nt.c
+    thr_pth.c
+    thr_stub.c
+    thr_debug.c
+)
+
+if(WIN32 AND "${LDAP_SHARED}" STREQUAL "SHARED")
+    list(APPEND ldap_r_add_SRCS ldap_r.rc)
+endif()
+
+add_library(ldap_r ${LDAP_SHARED} ${ldap_r_SRCS} ${ldap_r_add_SRCS})
+set_target_properties(ldap_r PROPERTIES DEFINE_SYMBOL LDAP_LIBRARY)
+target_link_libraries(ldap_r lber)
+if(${SASL2_FOUND})
+    target_link_libraries (ldap_r ${SASL2_LIBRARIES})
+endif()
+if(${OPENSSL_FOUND})
+    target_link_libraries (ldap_r ${OPENSSL_LIBRARIES})
+endif()
+install(TARGETS ldap_r ${INSTALL_TARGETS_DEFAULT_ARGS})
diff --git a/src/libraries/libldap_r/ldap_r.rc b/src/libraries/libldap_r/ldap_r.rc
new file mode 100644
index 0000000..62d4ba4
--- /dev/null
+++ b/src/libraries/libldap_r/ldap_r.rc
@@ -0,0 +1,45 @@
+#include <windows.h>
+#include "portable.h"
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION LDAP_RC_FILE_VERSION
+ PRODUCTVERSION LDAP_RC_PRODUCT_VERSION
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904e2"
+        BEGIN
+            VALUE "Comments", "OpenLDAP Software is an open source implementation of the Lightweight Directory Access Protocol.\0"
+            VALUE "CompanyName", "OpenLDAP Foundation\0"
+            VALUE "FileDescription", "OpenLDAP library\0"
+            VALUE "FileVersion", LDAP_RC_FILE_VERSION_STR
+            VALUE "InternalName", "lbap_r\0"
+            VALUE "LegalCopyright", "The OpenLDAP Public License\0"
+            VALUE "LegalTrademarks", "See http://www.openldap.org/software/release/license.html\0"
+            VALUE "OriginalFilename", "lbap_r.dll\0"
+            VALUE "PrivateBuild", "\0"
+            VALUE "ProductName", "OpenLDAP library\0"
+            VALUE "ProductVersion", LDAP_RC_PRODUCT_VERSION_STR
+            VALUE "SpecialBuild", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1250
+    END
+END
+
diff --git a/src/libraries/libldap_r/thr_nt.c b/src/libraries/libldap_r/thr_nt.c
index e5442f2..cb9f080 100644
--- a/src/libraries/libldap_r/thr_nt.c
+++ b/src/libraries/libldap_r/thr_nt.c
@@ -18,7 +18,9 @@
 
 #if defined( HAVE_NT_THREADS )
 
+#ifndef _WIN32_WINNT
 #define _WIN32_WINNT 0x0400
+#endif
 #include <windows.h>
 #include <process.h>
 
diff --git a/src/libraries/liblunicode/CMakeLists.txt b/src/libraries/liblunicode/CMakeLists.txt
new file mode 100644
index 0000000..e9b46fe
--- /dev/null
+++ b/src/libraries/liblunicode/CMakeLists.txt
@@ -0,0 +1,30 @@
+#set(UCGENDAT_SRC
+#ucdata.c
+#ucgendat.c
+#ure.c
+#urestubs.c
+#)
+
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/ucdata)
+
+add_executable(ucgendat ${CMAKE_CURRENT_SOURCE_DIR}/ucdata/ucgendat.c)
+target_link_libraries(ucgendat lutil lber Threads::Threads)
+
+add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/uctable.h COMMAND "$<TARGET_FILE:ucgendat>" ${CMAKE_CURRENT_SOURCE_DIR}/UnicodeData.txt -x ${CMAKE_CURRENT_SOURCE_DIR}/CompositionExclusions.txt DEPENDS $<TARGET_FILE:ucgendat>)
+
+set(lunicode_SRCS
+    ${CMAKE_CURRENT_BINARY_DIR}/uctable.h
+    ucdata/ucdata.c
+    ure/ure.c
+    ure/urestubs.c
+    ucstr.c
+)
+
+if(WIN32 AND "${LDAP_SHARED}" STREQUAL "SHARED")
+    list(APPEND lunicode_SRCS lunicode.rc)
+endif()
+
+add_library(lunicode ${LDAP_SHARED} ${lunicode_SRCS})
+set_target_properties(lunicode PROPERTIES DEFINE_SYMBOL LUNICODE_LIBRARY)
+target_link_libraries(lunicode ldap lber lutil)
+install(TARGETS lunicode ${INSTALL_TARGETS_DEFAULT_ARGS})
diff --git a/src/libraries/liblunicode/lunicode.rc b/src/libraries/liblunicode/lunicode.rc
new file mode 100644
index 0000000..47e54ff
--- /dev/null
+++ b/src/libraries/liblunicode/lunicode.rc
@@ -0,0 +1,45 @@
+#include <windows.h>
+#include "portable.h"
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION LDAP_RC_FILE_VERSION
+ PRODUCTVERSION LDAP_RC_PRODUCT_VERSION
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904e2"
+        BEGIN
+            VALUE "Comments", "OpenLDAP Software is an open source implementation of the Lightweight Directory Access Protocol.\0"
+            VALUE "CompanyName", "OpenLDAP Foundation\0"
+            VALUE "FileDescription", "OpenLDAP library\0"
+            VALUE "FileVersion", LDAP_RC_FILE_VERSION_STR
+            VALUE "InternalName", "lunicode\0"
+            VALUE "LegalCopyright", "The OpenLDAP Public License\0"
+            VALUE "LegalTrademarks", "See http://www.openldap.org/software/release/license.html\0"
+            VALUE "OriginalFilename", "lunicode.dll\0"
+            VALUE "PrivateBuild", "\0"
+            VALUE "ProductName", "OpenLDAP library\0"
+            VALUE "ProductVersion", LDAP_RC_PRODUCT_VERSION_STR
+            VALUE "SpecialBuild", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1250
+    END
+END
+
diff --git a/src/libraries/liblutil/CMakeLists.txt b/src/libraries/liblutil/CMakeLists.txt
new file mode 100644
index 0000000..ad2acfa
--- /dev/null
+++ b/src/libraries/liblutil/CMakeLists.txt
@@ -0,0 +1,37 @@
+set(lutil_SRCS
+    base64.c
+    entropy.c
+    sasl.c
+    signal.c
+    hash.c
+    passfile.c
+    md5.c
+    passwd.c
+    sha1.c
+    getpass.c
+    lockf.c
+    utils.c
+    uuid.c
+    sockpair.c
+    avl.c
+    tavl.c
+    meter.c
+)
+
+if(WIN32)
+    list(APPEND lutil_SRCS getopt.c ntservice.c slapdmsg.rc)
+    if("${LDAP_SHARED}" STREQUAL "SHARED")
+        list(APPEND lutil_SRCS lutil.rc)
+    endif()
+endif(WIN32)
+if(UNIX)
+    list(APPEND lutil_SRCS detach.c)
+endif(UNIX)
+
+add_library(lutil ${LDAP_SHARED} ${lutil_SRCS})
+set_target_properties(lutil PROPERTIES DEFINE_SYMBOL LUTIL_LIBRARY)
+target_link_libraries(lutil ldap_r lber)
+if(WIN32)
+    target_link_libraries(lutil rpcrt4)
+endif(WIN32)
+install(TARGETS lutil ${INSTALL_TARGETS_DEFAULT_ARGS})
diff --git a/src/libraries/liblutil/lutil.rc b/src/libraries/liblutil/lutil.rc
new file mode 100644
index 0000000..effefb5
--- /dev/null
+++ b/src/libraries/liblutil/lutil.rc
@@ -0,0 +1,45 @@
+#include <windows.h>
+#include "portable.h"
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION LDAP_RC_FILE_VERSION
+ PRODUCTVERSION LDAP_RC_PRODUCT_VERSION
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904e2"
+        BEGIN
+            VALUE "Comments", "OpenLDAP Software is an open source implementation of the Lightweight Directory Access Protocol.\0"
+            VALUE "CompanyName", "OpenLDAP Foundation\0"
+            VALUE "FileDescription", "OpenLDAP library\0"
+            VALUE "FileVersion", LDAP_RC_FILE_VERSION_STR
+            VALUE "InternalName", "lutil\0"
+            VALUE "LegalCopyright", "The OpenLDAP Public License\0"
+            VALUE "LegalTrademarks", "See http://www.openldap.org/software/release/license.html\0"
+            VALUE "OriginalFilename", "lutil.dll\0"
+            VALUE "PrivateBuild", "\0"
+            VALUE "ProductName", "OpenLDAP library\0"
+            VALUE "ProductVersion", LDAP_RC_PRODUCT_VERSION_STR
+            VALUE "SpecialBuild", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1250
+    END
+END
+
diff --git a/src/libraries/librewrite/CMakeLists.txt b/src/libraries/librewrite/CMakeLists.txt
new file mode 100644
index 0000000..ca745b8
--- /dev/null
+++ b/src/libraries/librewrite/CMakeLists.txt
@@ -0,0 +1,31 @@
+set(rewrite_SRCS
+    config.c
+    context.c
+    info.c
+    ldapmap.c
+    map.c
+    params.c
+    rule.c
+    session.c
+    subst.c
+    var.c
+    xmap.c
+    parse.c
+)
+
+if(WIN32 AND "${LDAP_SHARED}" STREQUAL "SHARED")
+    list(APPEND rewrite_SRCS rewrite.rc)
+endif()
+
+add_library(rewrite ${LDAP_SHARED} ${rewrite_SRCS})
+set_target_properties(rewrite PROPERTIES DEFINE_SYMBOL REWRITE_LIBRARY)
+target_link_libraries(rewrite lber lutil)
+target_link_libraries(rewrite ${PCRE_LIBRARIES})
+
+set(rewrite_bin_SRCS
+    rewrite.c
+)
+add_executable(rewrite_bin ${rewrite_bin_SRCS})
+target_link_libraries(rewrite_bin rewrite ldap_r lber lutil Threads::Threads)
+set_target_properties(rewrite_bin PROPERTIES RUNTIME_OUTPUT_NAME rewrite)
+install(TARGETS rewrite rewrite_bin ${INSTALL_TARGETS_DEFAULT_ARGS})
diff --git a/src/libraries/librewrite/config.c b/src/libraries/librewrite/config.c
index f04441c..bd6ba37 100644
--- a/src/libraries/librewrite/config.c
+++ b/src/libraries/librewrite/config.c
@@ -22,6 +22,8 @@
 #include "rewrite-int.h"
 #include "rewrite-map.h"
 
+// this is needed to export ldap_debug and ldap_syslog and ldap_syslog_level
+#include <ldap_log.h>
 /*
  * Parses a plugin map
  */
diff --git a/src/libraries/librewrite/rewrite.c b/src/libraries/librewrite/rewrite.c
index 1d27188..0165516 100644
--- a/src/libraries/librewrite/rewrite.c
+++ b/src/libraries/librewrite/rewrite.c
@@ -18,6 +18,7 @@
  */
 
 #include <portable.h>
+#include <ldap_cdefs.h>
 
 #include <ac/stdlib.h>
 #include <ac/string.h>
@@ -33,10 +34,6 @@
 #include <lutil.h>
 #include <ldap.h>
 
-int ldap_debug;
-int ldap_syslog;
-int ldap_syslog_level;
-
 static void
 apply( 
 		FILE *fin, 
diff --git a/src/libraries/librewrite/rewrite.rc b/src/libraries/librewrite/rewrite.rc
new file mode 100644
index 0000000..db6e687
--- /dev/null
+++ b/src/libraries/librewrite/rewrite.rc
@@ -0,0 +1,45 @@
+#include <windows.h>
+#include "portable.h"
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION LDAP_RC_FILE_VERSION
+ PRODUCTVERSION LDAP_RC_PRODUCT_VERSION
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904e2"
+        BEGIN
+            VALUE "Comments", "OpenLDAP Software is an open source implementation of the Lightweight Directory Access Protocol.\0"
+            VALUE "CompanyName", "OpenLDAP Foundation\0"
+            VALUE "FileDescription", "OpenLDAP library\0"
+            VALUE "FileVersion", LDAP_RC_FILE_VERSION_STR
+            VALUE "InternalName", "rewrite\0"
+            VALUE "LegalCopyright", "The OpenLDAP Public License\0"
+            VALUE "LegalTrademarks", "See http://www.openldap.org/software/release/license.html\0"
+            VALUE "OriginalFilename", "rewrite.dll\0"
+            VALUE "PrivateBuild", "\0"
+            VALUE "ProductName", "OpenLDAP library\0"
+            VALUE "ProductVersion", LDAP_RC_PRODUCT_VERSION_STR
+            VALUE "SpecialBuild", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1250
+    END
+END
+
